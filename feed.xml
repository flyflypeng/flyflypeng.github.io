<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Fly Higher's Blog</title>
    <description>Do one thing and do it well.
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 22 Mar 2020 01:28:00 +0800</pubDate>
    <lastBuildDate>Sun, 22 Mar 2020 01:28:00 +0800</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>Mac 开发环境配置</title>
        <description>&lt;h2 id=&quot;mac-修改设置环境变量&quot;&gt;Mac 修改设置环境变量&lt;/h2&gt;
&lt;p&gt;Mac 中修改环境变量的方法和 Linux 中修改环境变量的方法类似，可以修改的文件主要分为两类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.bash_profile&lt;/code&gt;：一般在这个文件中设置用户级的环境变量&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/bashrc&lt;/code&gt;：一般在这个文件中添加系统级环境变量&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.zshrc&lt;/code&gt;：如果你的shell环境使用的是zsh的话，你可以在这个文件中设置环境变量。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;添加环境变量的方式就是通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;export&lt;/code&gt; 关键字来进行添加。&lt;/p&gt;

&lt;h2 id=&quot;iterm2-配置&quot;&gt;iTerm2 配置&lt;/h2&gt;

&lt;h3 id=&quot;主题配色&quot;&gt;主题配色&lt;/h3&gt;
&lt;p&gt;你可以根据你的喜好来选择终端主题颜色的配色方案。&lt;/p&gt;

&lt;p&gt;可以从&lt;a href=&quot;https://github.com/mbadolato/iTerm2-Color-Schemes&quot;&gt;mbadolato/iTerm2-Color-Schemes&lt;/a&gt;仓库下载iTerm2的主题配色。&lt;/p&gt;

&lt;p&gt;我选择的是==Cobalt Neon==主题，个人觉得非常不错。&lt;/p&gt;

&lt;p&gt;配置方法：
&lt;img src=&quot;https://blog-biezhi-me-1251171175.cos.ap-shanghai.myqcloud.com/public/images/2018/11/import_color_schemes.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;添加背景图片&quot;&gt;添加背景图片&lt;/h3&gt;

&lt;p&gt;更换背景图片方式：&lt;code class=&quot;highlighter-rouge&quot;&gt;iTerm2 -&amp;gt; Preferences -&amp;gt; Profiles -&amp;gt; Window -&amp;gt; BackGround Image&lt;/code&gt;勾选图片即可。&lt;/p&gt;

&lt;p&gt;非常好看的一张背景图，背景图片取自微软Surface Studio的4K壁纸(将近12MB大小)，非常漂亮，需要的可以自取&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;

&lt;p&gt;链接: https://pan.baidu.com/s/17zGm…
提取码: hg67&lt;/p&gt;

&lt;h3 id=&quot;快捷键&quot;&gt;快捷键&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Preferences -&amp;gt; Keys -&amp;gt; Hotkey -&amp;gt; Show/hide iTerm2 with a system wide hotkey&lt;/code&gt;设置快捷键 &lt;code class=&quot;highlighter-rouge&quot;&gt;command + option + i&lt;/code&gt; 快速显示和隐藏 iTerm。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;常用快捷键列表&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;shortcut key&lt;/th&gt;
          &lt;th&gt;description&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;⌘ + t&lt;/td&gt;
          &lt;td&gt;新建标签页&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;⌘ + n&lt;/td&gt;
          &lt;td&gt;新建窗口&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;⌘ + 数字&lt;/td&gt;
          &lt;td&gt;切换标签页&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;⌘ + enter&lt;/td&gt;
          &lt;td&gt;切换全屏&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;⌘ + d&lt;/td&gt;
          &lt;td&gt;左右分屏&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;⇧⌘ + d&lt;/td&gt;
          &lt;td&gt;上下分屏&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;⌘ + ;&lt;/td&gt;
          &lt;td&gt;自动补全历史记录&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;zsh&quot;&gt;zsh&lt;/h2&gt;
&lt;p&gt;官网：&lt;a href=&quot;http://ohmyz.sh/ß&quot;&gt;zsh&lt;/a&gt;
使用教程链接：&lt;a href=&quot;http://yijiebuyi.com/blog/b9b5e1ebb719f22475c38c4819ab8151.html&quot;&gt;oh-my-zsh配置你的zsh提高shell逼格终极选择&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;zsh的主题文件存储在 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.oh-my-zsh/thees&lt;/code&gt; 目录下，你可以自己从github上淘到一些非常酷炫的的主题配置，然后下载存放到该目录下。&lt;/p&gt;

&lt;p&gt;推荐一个带PowerBar的非常骚的一个主题配置：&lt;a href=&quot;https://github.com/Powerlevel9k/powerlevel9k&quot;&gt;powerlevel9k&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;字体下载&amp;amp;配置：&lt;a href=&quot;https://github.com/bhilburn/powerlevel9k/wiki/Install-Instructions#step-2-install-a-powerline-font&quot;&gt;Install Powerline Fonts&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;zsh插件推荐&quot;&gt;zsh插件推荐&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/zsh-users/zsh-autosuggestions&quot;&gt;zsh-users/zsh-autosuggestions&lt;/a&gt;：基于输入的历史命令，在输入命令时进行补全提示
&lt;a href=&quot;https://github.com/zsh-users/zsh-syntax-highlighting&quot;&gt;zsh-users/zsh-syntax-highlighting&lt;/a&gt;：高亮你的 zsh 可用命令&lt;/p&gt;

&lt;h2 id=&quot;xcode-command-line-tools&quot;&gt;Xcode command line tools&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Xcode command line tools&lt;/code&gt; 是 Mac 下面一系列重要程序开发工具命令的集合，例如：ake, gcc, g++, clang, perl, svn, git等等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装方法&lt;/strong&gt;
直接打开命令行终端，通过下面的命令安装即可：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ xcode-select --install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;卸载方法&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo rm -rf /Library/Developer/CommandLineTools
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;查看-xcode-command-line-tools-中安装的命令集合的方法&quot;&gt;查看 Xcode command line tools 中安装的命令集合的方法&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ls /Library/Developer/CommandLineTools/usr/bin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;vim-编辑器使用技巧&quot;&gt;vim 编辑器使用技巧&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://harttle.land/assets/img/blog/vim-key.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://harttle.land/2015/11/07/vim-cursor.html&quot;&gt;Vim中如何快速进行光标移动&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;sublime-text-3&quot;&gt;Sublime Text 3&lt;/h2&gt;

&lt;h3 id=&quot;在命令行终端启动-sublime-text-3-的方法&quot;&gt;在命令行终端启动 sublime text 3 的方法&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;sudo ln&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl&quot;&lt;/span&gt; /usr/local/bin/subl 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;配置-cc-代码编译环境&quot;&gt;配置 C/C++ 代码编译环境&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Tools -&amp;gt; Build System -&amp;gt; New Buld System&lt;/code&gt; 新建编译系统，在新打开的窗口中替换下面的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
	&quot;cmd&quot;: [&quot;bash&quot;, &quot;-c&quot;, &quot;g++ '${file}' -o '${file_path}/${file_base_name}' &amp;amp;&amp;amp; osascript -e 'tell application \&quot;Terminal\&quot; to activate do script \&quot;clear&amp;amp;&amp;amp;${file_path}/${file_base_name} &amp;amp;&amp;amp; read -p \\\&quot;Press Enter to exit.\\\&quot;&amp;amp;&amp;amp;exit\&quot;'&quot;],
    &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;,
    &quot;working_dir&quot;: &quot;${file_path}&quot;,
    &quot;selector&quot;: &quot;source.c, source.c++&quot;,

    &quot;variants&quot;:
    [
        {
            &quot;name&quot;: &quot;Run&quot;,
            &quot;cmd&quot;: [&quot;bash&quot;, &quot;-c&quot;, &quot;g++ '${file}' -o '${file_path}/${file_base_name}' &amp;amp;&amp;amp; '${file_path}/${file_base_name}'&quot;]
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Command + s&lt;/code&gt; 保存，命名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;MyC++&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;然后我们在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Tools -&amp;gt; Build System&lt;/code&gt; 选中 &lt;code class=&quot;highlighter-rouge&quot;&gt;MyC++&lt;/code&gt; 作为默认的编译脚本。&lt;/p&gt;

&lt;p&gt;最后，每当我们编写完 C/C++ 代码时，就可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Command + Shift + B&lt;/code&gt; 快捷键编译并运行程序了（&lt;strong&gt;注意选择不带 Run 那个选项&lt;/strong&gt;），它默认会打开并跳转到一个终端界面去执行程序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果不需要从标准输入中读取输入数据，那么我们可以在调用快捷键 Command + Shift + B 之后弹出的选择框中选择加 Run 的选项来直接在 Sublime Text 中运行程序并看到最终程序运行输出的结果。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;让-sublime-记住上一次关闭前打开的文件&quot;&gt;让 Sublime 记住上一次关闭前打开的文件&lt;/h3&gt;
&lt;p&gt;只需要在 Sublime Text 3 退出时，按 &lt;code class=&quot;highlighter-rouge&quot;&gt;command + q&lt;/code&gt; 键退出即可。&lt;/p&gt;

&lt;h2 id=&quot;brew-包管理工具&quot;&gt;brew 包管理工具&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;brew&lt;/code&gt; 是 Mac 下的第三方包管理工具，它类似于 Ubuntu 系统中自带的 &lt;code class=&quot;highlighter-rouge&quot;&gt;apt&lt;/code&gt; 包管理工具。&lt;/p&gt;

&lt;p&gt;具体的安装方法详见官网：&lt;a href=&quot;http://brew.sh/index_zh-cn.html&quot;&gt;Homebrew&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在终端中运行以下命令，确保 brew 运行正常：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;brew doctor
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;brew&lt;/code&gt; 安装命令行工具的方法：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;brew &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &amp;lt;package_name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;安装完成之后，&lt;code class=&quot;highlighter-rouge&quot;&gt;brew&lt;/code&gt; 默认将命令行工具安装到 &lt;em&gt;/usr/local/bin&lt;/em&gt;
 目录下面。&lt;/p&gt;

&lt;h3 id=&quot;brew-常用命令&quot;&gt;brew 常用命令&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;brew search &amp;lt;pkg_name&amp;gt;  &lt;span class=&quot;c&quot;&gt;#查找软件包&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;brew &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &amp;lt;pkg_name&amp;gt;  &lt;span class=&quot;c&quot;&gt;#安装软件包&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;brew list &lt;span class=&quot;c&quot;&gt;#列出软件包&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;brew uninstall &amp;lt;pkg_name&amp;gt; &lt;span class=&quot;c&quot;&gt;#卸载软件包&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;brew update &lt;span class=&quot;c&quot;&gt;#更新&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;brew info &amp;lt;pkg_name&amp;gt; &lt;span class=&quot;c&quot;&gt;#查看软件包的基本资料&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;安装-nodejs&quot;&gt;安装 Node.js&lt;/h2&gt;

&lt;h3 id=&quot;安装-nvm-node-version-manager&quot;&gt;安装 NVM （Node Version Manager）&lt;/h3&gt;

&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;brew&lt;/code&gt; 安装 nvm&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;nvm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;配置 nvm 相关环境变量&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# You should create NVM's working directory if it doesn't exist:&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; ~/.nvm

&lt;span class=&quot;c&quot;&gt;# Add the following to ~/.zshrc or your desired shell&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#configuration file:&lt;/span&gt;

  &lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;NVM_DIR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/.nvm&quot;&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/usr/local/opt/nvm/nvm.sh&quot;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;测试 nvm 是否安装成功&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  ~ nvm

Node Version Manager

Note: &amp;lt;version&amp;gt; refers to any version-like string nvm understands. This includes:
  - full or partial version numbers, starting with an optional &lt;span class=&quot;s2&quot;&gt;&quot;v&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0.10, v0.1.2, v1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  - default &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;built-in&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; aliases: node, stable, unstable, iojs, system
  - custom aliases you define with &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;nvm &lt;span class=&quot;nb&quot;&gt;alias &lt;/span&gt;foo&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;

 Any options that produce colorized output should respect the &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;--no-colors&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt; option.

Usage:
  nvm &lt;span class=&quot;nt&quot;&gt;--help&lt;/span&gt;                                Show this message
  nvm &lt;span class=&quot;nt&quot;&gt;--version&lt;/span&gt;                             Print out the latest released version of nvm
  nvm &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &amp;lt;version&amp;gt;                Download and &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;a &amp;lt;version&amp;gt;, &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; from source. Uses .nvmrc &lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;available
    &lt;span class=&quot;nt&quot;&gt;--reinstall-packages-from&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;lt;version&amp;gt;     When installing, reinstall packages installed &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &amp;lt;node|iojs|node version number&amp;gt;
    &lt;span class=&quot;nt&quot;&gt;--lts&lt;/span&gt;                                   When installing, only &lt;span class=&quot;k&quot;&gt;select &lt;/span&gt;from LTS &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;long-term support&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; versions
    &lt;span class=&quot;nt&quot;&gt;--lts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;lt;LTS name&amp;gt;                        When installing, only &lt;span class=&quot;k&quot;&gt;select &lt;/span&gt;from versions &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;a specific LTS line
  nvm uninstall &amp;lt;version&amp;gt;                   Uninstall a version
  nvm uninstall &lt;span class=&quot;nt&quot;&gt;--lts&lt;/span&gt;                       Uninstall using automatic LTS &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;long-term support&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;alias&lt;/span&gt; &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;lts/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;, &lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;available.
  nvm uninstall &lt;span class=&quot;nt&quot;&gt;--lts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;lt;LTS name&amp;gt;            Uninstall using automatic &lt;span class=&quot;nb&quot;&gt;alias &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;provided LTS line, &lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;available.
  nvm use &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;--silent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &amp;lt;version&amp;gt;              Modify PATH to use &amp;lt;version&amp;gt;. Uses .nvmrc &lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;available
    &lt;span class=&quot;nt&quot;&gt;--lts&lt;/span&gt;                                   Uses automatic LTS &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;long-term support&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;alias&lt;/span&gt; &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;lts/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;, &lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;available.
    &lt;span class=&quot;nt&quot;&gt;--lts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;lt;LTS name&amp;gt;                        Uses automatic &lt;span class=&quot;nb&quot;&gt;alias &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;provided LTS line, &lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;available.
    ......
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;使用-nvm-安裝-nodejs&quot;&gt;使用 NVM 安裝 Node.js&lt;/h3&gt;
&lt;p&gt;找出目前所有可安裝的 Node.js 版本&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;nvm ls-remote
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;安装当前最新的稳定版本的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node.js&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;nvm &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;stable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;测试安装的 Node.js&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  ~ node &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt;
v7.2.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;测试 npm&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  ~ npm &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt;
3.10.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;修改-npm-包管理器下载的镜像源&quot;&gt;修改 npm 包管理器下载的镜像源&lt;/h3&gt;
&lt;p&gt;使用 taobo 定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'\n#alias for cnpm\nalias cnpm=&quot;npm --registry=https://registry.npm.taobao.org \
  --cache=$HOME/.npm/.cache/cnpm \
  --disturl=https://npm.taobao.org/dist \
  --userconfig=$HOME/.cnpmrc&quot;'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; ~/.zshrc &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; ~/.zshrc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;安装模块&lt;/strong&gt;
从 registry.npm.taobao.org 安装所有模块. 当安装的时候发现安装的模块还没有同步过来, 淘宝 NPM 会自动在后台进行同步, 并且会让你从官方 NPM registry.npmjs.org 进行安装. 下次你再安装这个模块的时候, 就会直接从 淘宝 NPM 安装了.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//使用这种方法安装 node 模块时，在终端一定要取消掉 http_proxy 和 https_proxy 代理·

&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; Blockquote

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;cnpm &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;name]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;同步模块&lt;/strong&gt;
直接通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;sync&lt;/code&gt; 命令马上同步一个模块, 只有 &lt;code class=&quot;highlighter-rouge&quot;&gt;cnpm&lt;/code&gt; 命令行才有此功能:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;cnpm &lt;span class=&quot;nb&quot;&gt;sync &lt;/span&gt;connect
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;剪贴板管理命令pbcopy-和-pbpaste&quot;&gt;剪贴板管理命令：pbcopy 和 pbpaste&lt;/h2&gt;
&lt;p&gt;这两个工具可以打通命令行和剪贴板。当然用鼠标操作复制粘贴也可以——但这两个工具的真正威力，发挥在将其用作Unix工具的时候。意思就是说：可以将这两个工具用作管道、IO重定向以及和其他命令的整合。例如：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; ~ | pbcopy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可以将主目录的文件列表复制到剪贴板。&lt;/p&gt;

&lt;p&gt;也可以把任意文件的内容复制到剪贴板中：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;pbcopy &amp;lt; blogpost.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;将剪贴板中的内容输出保存到一个文件中：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;pbpaset &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; test.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;图床工具-picu&quot;&gt;图床工具 PicU&lt;/h2&gt;
&lt;p&gt;PicU 软件可以将本地的图片上传到指定的图床平台，然后将上传后返回的图片链接复制到系统的粘贴板，而且为了方便 Markdown 写作者时使用外链图片格式，可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;⌘ + M&lt;/code&gt; 来获取 Markdown 格式的图片链接格式。&lt;/p&gt;

&lt;h2 id=&quot;omnigraffle&quot;&gt;OmniGraffle&lt;/h2&gt;
&lt;p&gt;OmniGraffle 是 Mac 上非常强大的绘图软件，它可以绘制流程图，思维导图，产品原型图等等，而且还有非常丰富的 &lt;code class=&quot;highlighter-rouge&quot;&gt;stencils&lt;/code&gt; 模板，直接导入然后进行修改，得到自己想要的图形。&lt;/p&gt;

&lt;h2 id=&quot;ruby-安装&quot;&gt;Ruby 安装&lt;/h2&gt;

&lt;h3 id=&quot;安装-rvm&quot;&gt;安装 RVM&lt;/h3&gt;
&lt;p&gt;RVM是Ruby的版本管理工具，我们可以使用它来帮助我们安装Ruby。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-L&lt;/span&gt; get.rvm.io | bash &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; stable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，我们需要再入RVM环境。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; ~/.rvm/scripts/rvm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;rvm -v&lt;/code&gt; 就可以检查RVM是否安装成功了。&lt;/p&gt;

&lt;h3 id=&quot;使用rvm安装ruby&quot;&gt;使用RVM安装Ruby&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rvm install 2.0.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;等一段时间，Ruby，Ruby Gems就安装好了。&lt;/p&gt;

&lt;p&gt;可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;gem -v&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ruby -v&lt;/code&gt;来检查是否安装成功。&lt;/p&gt;

&lt;h3 id=&quot;替换掉gem的默认源地址&quot;&gt;替换掉Gem的默认源地址&lt;/h3&gt;
&lt;p&gt;在国内，我们要想使用gem来安装相关的包的话，如果使用gem源地址，一般情况下都会安装失败，所以，我们需要将其替换为国内的网址。&lt;/p&gt;

&lt;p&gt;请尽可能用比较新的 RubyGems 版本，建议 2.6.x 以上。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;gem update &lt;span class=&quot;nt&quot;&gt;--system&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 这里请翻墙一下&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;gem &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt;
2.6.3

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;gem sources &lt;span class=&quot;nt&quot;&gt;--add&lt;/span&gt; https://gems.ruby-china.org/ &lt;span class=&quot;nt&quot;&gt;--remove&lt;/span&gt; https://rubygems.org/
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;gem sources &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt;
https://gems.ruby-china.org
&lt;span class=&quot;c&quot;&gt;# 确保只有 gems.ruby-china.org&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;避免-gem-安装包时使用-sudo&quot;&gt;避免 gem 安装包时使用 sudo&lt;/h3&gt;
&lt;p&gt;首先，需要将 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.gem/ruby/2.4.0/bin&lt;/code&gt; 路径添加系统环境变量 &lt;strong&gt;PATH&lt;/strong&gt; 当中。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vim .zshrc

&lt;span class=&quot;c&quot;&gt;# add gem install package path into PATH&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$HOME&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/.gem/ruby/2.4.0/bin:&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$PATH&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后我们就可以通过下面的命令(注意带上参数 –user-install)将 ruby 包安装到 &lt;code class=&quot;highlighter-rouge&quot;&gt;$HOME/.gem/ruby/2.4.0/bin&lt;/code&gt; 中&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gem install &amp;lt;package-name&amp;gt; --user-install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;ssh-常用技巧&quot;&gt;ssh 常用技巧&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;免密登录远程主机&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; # 如果本机公钥还没有生成，那么可以使用命令：ssh-keygen 生成
 $ ssh-copy-id arclab@10.214.9.170
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;快速登录远程主机&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; # 为了避免每次 ssh 连接远程主机时输入一长串的 username@host-ip，可以将远程主机用一个简单的字符串来标识，修改方法如下
 $ vim ~/.ssh/config
 HOST droidocker
 User arclab
 Port 22
 HostName 10.214.9.170
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000014992947&quot;&gt;iTerm2 + Oh My Zsh 打造舒适终端体验&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 21 Mar 2020 09:00:01 +0800</pubDate>
        <link>http://localhost:4000/%E5%88%A9%E5%99%A8/2020/03/21/Mac-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E5%88%A9%E5%99%A8/2020/03/21/Mac-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html</guid>
        
        <category>Mac</category>
        
        <category>iTerm2</category>
        
        <category>zsh</category>
        
        <category>brew</category>
        
        
        <category>利器</category>
        
      </item>
    
      <item>
        <title>QEMU/KVM 原理综述</title>
        <description>&lt;h2 id=&quot;qemu-工作原理简介&quot;&gt;QEMU 工作原理简介&lt;/h2&gt;

&lt;p&gt;QEMU是一款开源的模拟器和虚拟机监视器（Virtual Machine Monitor, VMM）。QEMU主要提供两个功能给用户使用：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;作为用户态模拟器：通过动态代码翻译机制来执行不同架构的代码，例如在X86平台上模拟ARM平台下执行环境。&lt;/li&gt;
  &lt;li&gt;作为虚拟机监视器：模拟全系统，利用其它VMM（Xen，KVM等等）来使用硬件提供的虚拟化支持，创建接近于主机性能的虚拟机。&lt;/li&gt;
&lt;/ul&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;qemu虚拟化的主要原理&quot;&gt;QEMU虚拟化的主要原理&lt;/h3&gt;

&lt;p&gt;系统虚拟化最重要的就是虚拟化出计算机系统中最重要的三大组件：CPU、内存和IO设备。QEMU虚拟出来的CPU成为vCPU，为了提升vCPU执行Guest OS中指令的效率，通过KVM、Xen等虚拟化技术，直接利用CPU硬件虚拟化的支持，在主机上安全地执行虚拟机代码（需要BIOS中CPU开启对应的硬件虚拟化支持）。&lt;/p&gt;

&lt;p&gt;在x86平台上最常见的虚拟化组合就是QEMU/KVM的组合了，其中利用QEMU来模拟IO外设，通过KVM来捕获Guest OS中运行的指令并将其中非特权指令在物理CPU上直接运行，达到硬件加速的目的。&lt;/p&gt;

&lt;p&gt;KVM内核模块对用户空间只暴露出一个&lt;code class=&quot;highlighter-rouge&quot;&gt;/dev/kvm&lt;/code&gt;的设备文件，然后通过&lt;code class=&quot;highlighter-rouge&quot;&gt;ioctl&lt;/code&gt;命令与QEMU进程进行通信，KVM利用硬件扩展直接将虚拟机代码运行于主机之上，当vCPU需要执行访问IO设备寄存器的指令时，vCPU就会停止从退回到QEMU进程中，由QEMU去模拟操作的结果。&lt;/p&gt;

&lt;h2 id=&quot;kvm-虚拟化原理简介&quot;&gt;KVM 虚拟化原理简介&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;KVM是Linux内核的一个虚拟化特性，由一组内核模块文件组成，它可以让QEMU中运行的Guest OS的指令直接在Host OS上的CPU中执行，&lt;strong&gt;前提是Guest OS和Host OS的硬件架构相同&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;KVM解决了虚拟化中的哪个痛点？有什么优势？
  KVM主要解决的虚拟化中CPU虚拟化的问题，这部分详细内容可以参见&lt;strong&gt;CPU虚拟化&lt;/strong&gt;相关内容。
    &lt;ul&gt;
      &lt;li&gt;没有KVM虚拟化加速
  QEMU需要截获Guest OS中运行的所有指令，然后通过软件的方式模拟执行，如果是跨平台架构的Guest OS，那么还需要额外的二进制指令翻译，将Guest OS中目标架构的指令翻译成Host OS上所能执行的指令，导致虚拟化的效率非常低。&lt;/li&gt;
      &lt;li&gt;有KVM虚拟化加速
  如果QEMU中运行的Guest OS和Host OS的硬件架构相同，那么Guest OS中的指令可以直接在Host OS上的物理CPU上执行，而不需要通过QEMU软件模拟的方式去执行Guest OS中的指令，大大提高了Guest虚拟机的性能。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;QEMU结合KVM执行Guest OS指令的步骤简要描述&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;：
    &lt;blockquote&gt;
      &lt;p&gt;打开/dev/kvm设备文件、创建虚拟机、创建vCPU、向KVM模块发送KVM_RUN的ioctl调用，接下来KVM模块利用CPU上的硬件虚拟化扩展功能来直接执行guest的运行。当guest在执行过程中遇到读取硬件设备寄存器等I/O操作、暂停guest CPU或其他特殊指令等KVM无法执行的操作时，会退出当前KVM并交由Qemu处理。Qemu模拟器判断退出原因并执行相应的操作：如果是遇到I/O操作或特殊指令，Qemu会去模拟执行这些操作；如果是暂停guest CPU操作，Qemu停止并等待下一次guest中断。
  上述流程用下面的代码来简单表示：&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/dev/kvm&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
  &lt;span class=&quot;n&quot;&gt;ioctl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KVM_CREATE_VM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
  &lt;span class=&quot;n&quot;&gt;ioctl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KVM_CREATE_VCPU&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    
       &lt;span class=&quot;n&quot;&gt;ioctl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KVM_RUN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
       &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exit_reason&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 分析退出原因，并执行相应操作 */&lt;/span&gt;
    
       &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;KVM_EXIT_IO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt;
    
       &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;KVM_EXIT_HLT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt;
    
       &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Host, QEMU, Guest之间的关系图
  &lt;img src=&quot;http://97.64.33.222/temp/1811/99149dd24c5fc6b2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;参考文章&quot;&gt;参考文章&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/xiongwenwu/article/details/58586013&quot;&gt;KVM/Qemu 工作原理系列目录&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/community/blogs/5144904d-5d75-45ed-9d2b-cf1754ee936a/entry/20160805?lang=en&quot;&gt;QEMU深入解析：综述篇&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 21 Nov 2018 08:12:33 +0800</pubDate>
        <link>http://localhost:4000/%E8%99%9A%E6%8B%9F%E5%8C%96/2018/11/21/QEMU-KVM-%E5%8E%9F%E7%90%86%E7%BB%BC%E8%BF%B0.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E8%99%9A%E6%8B%9F%E5%8C%96/2018/11/21/QEMU-KVM-%E5%8E%9F%E7%90%86%E7%BB%BC%E8%BF%B0.html</guid>
        
        <category>虚拟化</category>
        
        <category>QEMU</category>
        
        <category>KVM</category>
        
        
        <category>虚拟化</category>
        
      </item>
    
      <item>
        <title>Android 系统图形栈（二）：OpenGL ES 库和 EGL 库加载过程</title>
        <description>&lt;h2 id=&quot;1-opengl-es-和-opengl-es-库的区别&quot;&gt;1. OpenGL ES 和 OpenGL ES 库的区别&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;OpenGL ES&lt;/strong&gt; ： 它本身只是一个协议规范，定义了一套可以供上层应用程序进行调用的 API，它抽象了 GPU 的功能，使应用开发者不必关心底层的 GPU 类型和具体实现。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;OpenGL ES 库&lt;/strong&gt;：OpenGL ES 库就是上面 OpenGL ES 中定义的 API 的具体实现。由于每个显卡制造厂商的 GPU 硬件结构不同，从而导致各个厂商的OpenGL ES 库也各不相同，所以 Android 系统中的 OpenGL ES 库通常是由硬件厂商提供的，通常存放在 Android 系统中的 &lt;em&gt;/system/lib64/egl&lt;/em&gt; 下面或者 &lt;em&gt;/vendor/lib64/egl&lt;/em&gt; 目录下。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;OpenGL ES Wrapper 库&lt;/strong&gt;：OpenGL ES Wrapper 库是一个对 OpenGL ES API 进行封装的一个包裹库，它向上为应用程序提供了标准的 OpenGL ES API，向下可以和不同厂商实现的 OpenGL ES 库进行绑定，将 OpenGL ES API 和对应的实现函数一一绑定在一起。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;并且，OpenGL ES 库的实现分为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;软件模拟实现&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;硬件加速实现&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;现在，因为我们 Android 手机中的 Soc 片上芯片中都集成了 GPU 模块，所以这里使用的就是硬件加速实现的 OpenGL ES 库。但是，像 Android Emulator 中的 Android 系统，如果不支持将 OpenGL ES API 指令重定向到主机系统的 GPU 加速执行的话，它所采用的 OpenGL ES 库就是软件模拟实现的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;补充：&lt;/strong&gt;
同理，如前面一篇文章&lt;a href=&quot;http://woshijpf.github.io/android/2017/09/04/Android%E7%B3%BB%E7%BB%9F%E5%9B%BE%E5%BD%A2%E6%A0%88-OpenGLES%E5%92%8CEGL%E4%BB%8B%E7%BB%8D.html&quot;&gt;Android 系统图形栈: OpenGL ES 和 EGL 介绍&lt;/a&gt;中介绍的，EGL 也是一套 API，它的实现也需要系统厂商来提供。系统厂商通常会将这两套 API 的实现封装在一个共享链接库中，但是根据最新的标准，OpenGL ES API 实现的共享链接库和 EGL API 实现的共享链接库是独立分开的，例如 2.2 小节中列举的 Nexus 9 平板设备中 OpenGL ES 和 EGL API 实现库就是独立分开的。&lt;/p&gt;

&lt;h2 id=&quot;2-android-中-opengl-es-软件层次栈&quot;&gt;2. Android 中 OpenGL ES 软件层次栈&lt;/h2&gt;
&lt;p&gt;按照分层理念的设计，Android 中的 OpenGL ES 实现也是层次设计的，形成一个软件层次栈。最上面的是 Java 层，接着下面是 JNI 层，再调用下面的 wrapper 层，wrapper 层下面则是 OpenGL ES API 的具体软件实或者硬件实现了。整个 OpenGL 软件层次栈的调用关系如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://picturebed.obs.cn-east-2.myhuaweicloud.com/blogPictures/OpenGL_ES_call_graph.png&quot; alt=&quot;OpenGL 软件层次栈&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;21-opengl-esegl-wrapper-库&quot;&gt;2.1 OpenGL ES/EGL Wrapper 库&lt;/h3&gt;
&lt;p&gt;前面我们已经介绍过 OpenGL ES/EGL Wrapper 库是一个将 OpenGL ES API 和 OpenGL ES API 具体实现绑定在一起的库，它对应的源码路径是：&lt;em&gt;/frameworks/native/opengl/libs/&lt;/em&gt;，其中:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;libGLESv1_CM.so&lt;/code&gt;：OpenGL ES 1.x API 的 Wrapper 库&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;libGLESv2.so&lt;/code&gt;：OpenGL ES 2.0 的 Wrapper 库&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;libGLESv3.so&lt;/code&gt;：OpenGL ES 3.0 的 Wrapper 库&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中因为 OpenGL ES 3.0 API 是兼容 OpenGL ES 2.0 API 的，所以 &lt;code class=&quot;highlighter-rouge&quot;&gt;libGLESv2.so&lt;/code&gt; 库本质上和 &lt;code class=&quot;highlighter-rouge&quot;&gt;libGLESv3.so&lt;/code&gt; 库是一样的。&lt;/p&gt;

&lt;h3 id=&quot;22-opengl-esegl-实现库&quot;&gt;2.2 OpenGL ES/EGL 实现库&lt;/h3&gt;
&lt;p&gt;如果Android系统平台支持 OpenGL ES 硬件加速渲染，那么 OpenGL ES/EGL 实现库由系统厂商以&lt;code class=&quot;highlighter-rouge&quot;&gt;.so&lt;/code&gt;的共享链接库的形式提供，例如，Nexus 9 平板中的厂商提供的 OpenGL ES/EGL 实现库为：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;flounder:/vendor/lib64/egl &lt;span class=&quot;c&quot;&gt;# ls&lt;/span&gt;
libEGL_tegra.so libGLESv1_CM_tegra.so libGLESv2_tegra.so
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果Android系统平台不支持 OpenGL ES 硬件加速渲染，那么它就会默认启用软件模拟渲染，这时 OpenGL ES/EGL 实现库就是由 AOSP 提供，链接库的存在的路径为： &lt;code class=&quot;highlighter-rouge&quot;&gt;/system/lib64/egl/libGLES_android.so&lt;/code&gt;。而 &lt;code class=&quot;highlighter-rouge&quot;&gt;libGLES_android.so&lt;/code&gt; 库在 Android 7.1 系统对应的实现源码路径为：&lt;em&gt;/frameworks/native/opengl/libagl/&lt;/em&gt; 。&lt;/p&gt;

&lt;h2 id=&quot;3-android-71-中加载-opengl-es-库的过程&quot;&gt;3. Android 7.1 中加载 OpenGL ES 库的过程&lt;/h2&gt;
&lt;p&gt;Android 中图形渲染所采用的方式（硬件 or 软件）是在系统启动之后动态确定的，而确定渲染方式的这个源码文件就是 &lt;em&gt;/frameworks/native/opengl/libs/EGL/Loader.cpp&lt;/em&gt; 。&lt;/p&gt;

&lt;h3 id=&quot;31-android-71-opengl-es-库和-egl-库加载说明&quot;&gt;3.1 Android 7.1 OpenGL ES 库和 EGL 库加载说明&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.2net.co.uk/tutorial/android-egl-cgf-is-dead&quot;&gt;How Android finds OpenGL libraries, and the death of egl.cfg&lt;/a&gt; 这篇文章中提到了非常关键的一点，就是从 Android Kitkat 4.4 之后，Android 中加载 OpenGL ES/EGL 库的方法发生了变化了（&lt;strong&gt;但是整个加载过程都是由 /frameworks/native/opengl/libs/EGL/Loader.cpp 程序所决定的，也就是说 Loader.cpp 文件发生了变化&lt;/strong&gt;）。&lt;/p&gt;

&lt;p&gt;在 &lt;strong&gt;Android 4.4 之前&lt;/strong&gt;，加载 OpenGL ES 库是由 &lt;em&gt;/system/lib/egl/egl.cfg&lt;/em&gt; 文件所决定的，通过读取这个配置文件来确定是加载 OpenGL ES 软件模拟实现的库，还是OpenGL ES 硬件加速实现的库。&lt;/p&gt;

&lt;p&gt;但是，在Android 4.4 之后，Android 不再通过读取 egl.cfg 配置文件的方式来加载 OpenGL ES 库，新的加载 OpenGL ES 库的规则，如下所示：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从 &lt;em&gt;/system/lib/egl&lt;/em&gt; 或者 &lt;em&gt;/vendor/lib/egl/&lt;/em&gt; 目录下加载 libGLES.so 库文件或者 libEGL_vendor.so，libGLESv1_CM_vendor.so，libGLESv2_vendor.so 库文件。&lt;/li&gt;
  &lt;li&gt;为了向下兼容旧的库的命名方式，同样也会加载 &lt;em&gt;/system/lib/egl&lt;/em&gt; 或者 &lt;em&gt;/vendor/lib/egl/&lt;/em&gt; 目录下的 libGLES_*.so 或者 libEGL_*.so，libGLESv1&lt;em&gt;CM&lt;/em&gt;*.so，libGLESv2_*.so 库文件。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;32硬件加速渲染-or-软件模拟渲染&quot;&gt;3.2　硬件加速渲染 or 软件模拟渲染？&lt;/h3&gt;

&lt;p&gt;前面我们提到 OpenGL ES 库的实现方式有两种，一种是硬件加速实现，一种是软件模拟实现，那么系统是怎么确定加载那一种 OpenGL ES 库的呢？&lt;/p&gt;

&lt;p&gt;Android 7.1 源码中负责加载 OpenGL ES/EGL 库部分的代码位于：&lt;em&gt;/frameworks/native/opengl/libs/EGL/Loader.cpp&lt;/em&gt; 文件中，这个文件中代码的主要入口函数是 &lt;strong&gt;Loader::open()&lt;/strong&gt; 函数，而决定加载&lt;strong&gt;硬件加速渲染库&lt;/strong&gt;还是&lt;strong&gt;软件模拟渲染库&lt;/strong&gt;主要涉及到下面两个函数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;setEmulatorGlesValue()&lt;/li&gt;
  &lt;li&gt;checkGlesEmulationStatus()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面就来简要的分析一下 Android 系统是如何选择加载&lt;strong&gt;硬件加速渲染库&lt;/strong&gt;还是&lt;strong&gt;软件模拟渲染库&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;首先，&lt;code class=&quot;highlighter-rouge&quot;&gt;Loader::open()&lt;/code&gt; 入口函数会调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;setEmulatorGlesValue()&lt;/code&gt; 从 property 属性系统中获取一些属性值来判断当前 Android 系统是否在 Emulator 环境中运行，并根据读取出来的信息来重新设置新的属性键值对，setEmulatorGlesValue() 函数的代码如下所示：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; static void setEmulatorGlesValue(void) {
     char prop[PROPERTY_VALUE_MAX];
     property_get(&quot;ro.kernel.qemu&quot;, prop, &quot;0&quot;); //读取 ro.kernel.qemu 属性值，判断Android系统是否运行在 qemu 中
     if (atoi(prop) != 1) return;
    
     property_get(&quot;ro.kernel.qemu.gles&quot;, prop, &quot;0&quot;); //读取 ro.kernel.qemu.gles 属性值，判断 qemu 中 OpenGL ES 库的实现方式
     if (atoi(prop) == 1) {
         ALOGD(&quot;Emulator has host GPU support, qemu.gles is set to 1.&quot;);
         property_set(&quot;qemu.gles&quot;, &quot;1&quot;);
         return;
     }
    
     // for now, checking the following
     // directory is good enough for emulator system images
     const char* vendor_lib_path =
 #if defined(__LP64__)
         &quot;/vendor/lib64/egl&quot;;
 #else
         &quot;/vendor/lib/egl&quot;;
 #endif
    
     const bool has_vendor_lib = (access(vendor_lib_path, R_OK) == 0);
     //如果存在 vendor_lib_path 这个路径，那么就说明厂商提供了 OpenGL ES库自己的软件模拟渲染库，而不是 Android 系统自己编译得到的软件模拟渲染库
     if (has_vendor_lib) {
         ALOGD(&quot;Emulator has vendor provided software renderer, qemu.gles is set to 2.&quot;);
         property_set(&quot;qemu.gles&quot;, &quot;2&quot;);
     } else {
         ALOGD(&quot;Emulator without GPU support detected. &quot;
               &quot;Fallback to legacy software renderer, qemu.gles is set to 0.&quot;);
         property_set(&quot;qemu.gles&quot;, &quot;0&quot;); //最后，默认采取的是方案就是调用传统的Android系统自己编译得到软件模拟渲染库
     }
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;load_system_driver()&lt;/code&gt; 函数中，内部类 MatchFile 类中会调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;checkGlesEmulationStatus()&lt;/code&gt; 函数来检查 Android 系统是否运行在模拟器中，以及在模拟器中是否启用了主机硬件加速的功能，然后根据 checkGlesEmulationStatus() 函数的返回状态值来确定要加载共享链接库的文件绝对路径。load_system_driver() 和 checkGlesEmulationStatus() 函数代码如下所示：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; static void* load_system_driver(const char* kind) {
     ATRACE_CALL();
     class MatchFile {
     public:
         //这个函数作用是返回需要加载打开的 OpenGL ES 和 EGL API 实现库文件的绝对路径
         static String8 find(const char* kind) {
             String8 result;
             int emulationStatus = checkGlesEmulationStatus(); //检查 Android 系统是否运行在模拟器中，以及在模拟器中是否启用了主机硬件加速的功能
             switch (emulationStatus) {
             case 0: //Android 运行在模拟器中，使用系统软件模拟实现的 OpenGL ES API 库 libGLES_android.so
 #if defined(__LP64__)
                 result.setTo(&quot;/system/lib64/egl/libGLES_android.so&quot;);
 #else
                 result.setTo(&quot;/system/lib/egl/libGLES_android.so&quot;);
 #endif
                 return result;
             case 1: // Android 运行在模拟器中，通过主机系统中实现 OpenGL ES 加速渲染，通过 libGLES_emulation.so 库将  OpenGL ES API 指令重定向到 host 中执行
                 // Use host-side OpenGL through the &quot;emulation&quot; library
 #if defined(__LP64__)
                 result.appendFormat(&quot;/system/lib64/egl/lib%s_emulation.so&quot;, kind);
 #else
                 result.appendFormat(&quot;/system/lib/egl/lib%s_emulation.so&quot;, kind);
 #endif
                 return result;
             default:
                 // Not in emulator, or use other guest-side implementation
                 break;
             }
    
             // 如果不是上面两种情况，就根据库的命名规则去找到厂商实现库文件的绝对路径
             String8 pattern;
             pattern.appendFormat(&quot;lib%s&quot;, kind);
             const char* const searchPaths[] = {
 #if defined(__LP64__)
                 &quot;/vendor/lib64/egl&quot;,
                 &quot;/system/lib64/egl&quot;
 #else
                 &quot;/vendor/lib/egl&quot;,
                 &quot;/system/lib/egl&quot;
 #endif
             };
                
             ......
     }
        
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; static int
 checkGlesEmulationStatus(void)
 {
     /* We're going to check for the following kernel parameters:
      *
      *    qemu=1                      -&amp;gt; tells us that we run inside the emulator
      *    android.qemu.gles=&amp;lt;number&amp;gt;  -&amp;gt; tells us the GLES GPU emulation status
      *
      * Note that we will return &amp;lt;number&amp;gt; if we find it. This let us support
      * more additionnal emulation modes in the future.
      */
     char  prop[PROPERTY_VALUE_MAX];
     int   result = -1;
    
     /* Check if hardware acceleration disabled explicitly */
     property_get(&quot;debug.egl.hw&quot;, prop, &quot;1&quot;); //读取 debu.egl.hw 属性值，判断3D硬件加速功能是否被关闭了
     if (!atoi(prop)) {
         ALOGD(&quot;3D hardware acceleration is disabled&quot;);
         return 0;
     }
    
     /* First, check for qemu=1 */
     property_get(&quot;ro.kernel.qemu&quot;, prop, &quot;0&quot;); //读取ro.kernel.qemu，判断是否运行在 qemu 中
     if (atoi(prop) != 1)
         return -1;
    
     /* We are in the emulator, get GPU status value */
     property_get(&quot;qemu.gles&quot;, prop, &quot;0&quot;); // 如果 Android 系统运行在 qemu 中，就返回 qemu.gles 的值，根据这个值就可以确定加载的是那种 OpenGL ES 库了
     return atoi(prop);
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;总结一下上面代码的功能就是，首先判断 Android 是否在 qemu 虚拟机中运行，如果不是，那么就直接去加载厂商存放库的路径中去加载 OpenGL ES 实现库（不管是硬件加速实现的，还是软件模拟实现的）；如果是在 qemu 中运行，那么就要根据返回的 &lt;strong&gt;emulationStatus&lt;/strong&gt; 值 来确定是加软件模拟实现的 OpenGL ES API 库 &lt;code class=&quot;highlighter-rouge&quot;&gt;libGLES_android.so&lt;/code&gt;，还是加载 &lt;code class=&quot;highlighter-rouge&quot;&gt;libGLES_emulation.so&lt;/code&gt;库将 OpenGL ES 指令重定向到 Host 系统中去执行。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;33-opengl-esegl-库加载和解析过程&quot;&gt;3.3 OpenGL ES/EGL 库加载和解析过程&lt;/h3&gt;
&lt;p&gt;正如&lt;a href=&quot;http://woshijpf.github.io/android/2017/09/04/Android%E7%B3%BB%E7%BB%9F%E5%9B%BE%E5%BD%A2%E6%A0%88-OpenGLES%E5%92%8CEGL%E4%BB%8B%E7%BB%8D.html&quot;&gt;Android 系统图形栈: OpenGL ES 和 EGL 介绍&lt;/a&gt;这篇文章中分析的那样，在进行 OpenGL 编程时，最先开始需要获取 Display，这将调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;eglgGetDisplay()&lt;/code&gt; 函数被调用。在 eglGetDisplay() 里则会调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;egl_init_drivers()&lt;/code&gt; 初始化驱动：装载各个库进行解析，将 OpenGL ES/EGL API 函数接口和具体的实现绑定在一起，并将结果保存在 &lt;strong&gt;egl_connection_t&lt;/strong&gt; 类型的全局变量 &lt;strong&gt;gEGLImpl&lt;/strong&gt; 的结构体的成员变量中。&lt;/p&gt;

&lt;p&gt;下面以 SurfaceFlinger 进程为例进行分析，整个 OpenGL ES/EGL 库的加载和解析流程如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-flow&quot;&gt;st=&amp;gt;start: Start
op1=&amp;gt;operation: SurfaceFlinger::init()
sub=&amp;gt;subroutine: Your Subroutine
op2=&amp;gt;operation: eglGetDisplay(EGL_DEFAULT_DISPLAY)
op3=&amp;gt;operation: egl_init_drivers()
op4=&amp;gt;operation: egl_init_drivers_locked();
op5=&amp;gt;operation: loader.open()
op6=&amp;gt;operation: load_driver()
op7=&amp;gt;operation: load_system_driver()
op8=&amp;gt;operation: Loader::init_api()
e=&amp;gt;end

st-&amp;gt;op1-&amp;gt;op2-&amp;gt;op3-&amp;gt;op4-&amp;gt;op5-&amp;gt;op6-&amp;gt;op7-&amp;gt;op8-&amp;gt;e
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;331-geglimpl-全局变量&quot;&gt;3.3.1 gEGLImpl 全局变量&lt;/h4&gt;

&lt;p&gt;struct egl_connection_t 类型的 gEGLImpl 全局变量是一个非常重要变量，它里面的成员指向了打开的 OpenGL ES/EGL Wrapper 库和 OpenGL ES/EGL 实现库：
&lt;em&gt;/frameworks/native/opengl/libs/EGL/egl.cpp&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;egl_connection_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gEGLImpl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;gl_hooks_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gHooks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;gl_hooks_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gHooksNoContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中 egl_connection_t 的定义：
&lt;em&gt;/frameworks/native/opengl/libs/EGL/egldefs.h&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;egl_connection_t&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;GLESv1_INDEX&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;GLESv2_INDEX&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

    &lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;egl_connection_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dso&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;              &lt;span class=&quot;n&quot;&gt;dso&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//指向打开的共享链接库的句柄&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;gl_hooks_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;hooks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//指向打开的 OpenGL ES API 对象&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;EGLint&lt;/span&gt;              &lt;span class=&quot;n&quot;&gt;major&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 主版本好&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;EGLint&lt;/span&gt;              &lt;span class=&quot;n&quot;&gt;minor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;egl_t&lt;/span&gt;               &lt;span class=&quot;n&quot;&gt;egl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//dui x&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;               &lt;span class=&quot;n&quot;&gt;libEgl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;               &lt;span class=&quot;n&quot;&gt;libGles1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;               &lt;span class=&quot;n&quot;&gt;libGles2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面就对其中的主要成员进行一个说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;hooks：这是一个 gl_hook_t* 类型的指针数组，它最终将 OpenGL ES API 和实现库钩在一起。&lt;/li&gt;
  &lt;li&gt;egl：这是一个 egl_t 类型的成员变量，它最终将 EGL API 和 EGL 实现库了钩在一起。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么 gl_hook_t 和 egl_t 是什么呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;gl_hook_t&lt;/strong&gt; 和 &lt;strong&gt;egl_t&lt;/strong&gt; 的定义如下所示：
&lt;em&gt;/frameworks/native/opengl/libs/hooks.h&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#define GL_ENTRY(_r, _api, ...) _r (*_api)(__VA_ARGS__);
#define EGL_ENTRY(_r, _api, ...) _r (*_api)(__VA_ARGS__);
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;egl_t&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cp&quot;&gt;#include &quot;EGL/egl_entries.in&quot;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gl_hooks_t&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gl_t&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cp&quot;&gt;#include &quot;entries.in&quot;
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gl_ext_t&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// __eglMustCastToProperFunctionPointerType 是一个 typedef 的函数指针类型，它的返回值是void，参数也是void&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;__eglMustCastToProperFunctionPointerType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;extensions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX_NUMBER_OF_GL_EXTENSIONS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从上面的定义中我们发现，egl_t 和 gl_hooks_t 这两个结构体中主要就是一个 include 语句，那么它们包含的是什么呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;#include “EGL/egl_entries.in&lt;/strong&gt;
包含的文件路径如下所示：
&lt;em&gt;/frameworks/native/opengl/libs/EGL/egl_entries.in&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;EGL_ENTRY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EGLDisplay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eglGetDisplay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NativeDisplayType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;EGL_ENTRY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EGLBoolean&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eglInitialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EGLDisplay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EGLint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EGLint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;EGL_ENTRY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EGLBoolean&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eglTerminate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EGLDisplay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;EGL_ENTRY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EGLBoolean&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eglGetConfigs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EGLDisplay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EGLConfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EGLint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EGLint&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;EGL_ENTRY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EGLBoolean&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eglChooseConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EGLDisplay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EGLint&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EGLConfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EGLint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EGLint&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在这个文件中，我们可以看到所有的内容都是 EGL_ENTRY 宏定义的，根据 EGL_ENTRY 宏定义：
&lt;em&gt;/frameworks/native/opengl/libs/EGL/hooks.h&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//下面的两个宏定义分别是 OpenGL 和 EGL API 函数的函数指针变量
//这些函数变量最后会和具体的 OpenGL 和 EGL API 的实现绑定在一起
#define GL_ENTRY(_r,_api,...) _r (*_api)(__VA_ARGS__);
#define EGL_ENTRY(_r,_api,...) _r(*_api)(__VA_ARGS__);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们可以将下面的这个宏定义展开成如下的形式:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;EGL_ENTRY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EGLDisplay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eglGetDisplay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NativeDisplayType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//展开后的形式如下所示，它实际上就是 EGL API 函数声明&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;EGLDisplay&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eglGetDisplay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NativeDisplayType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;#include “entries.in”&lt;/strong&gt;
包含的文件路径为：
&lt;em&gt;/frameworks/native/opengl/libs/entries.in&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;GL_ENTRY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;glReadPixels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLsizei&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLsizei&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLenum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLenum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pixels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;和上面的 EGL_ENTRY 一样，GL_ENTRY 都是通过宏定义的形式来将 OpenGL ES 的 API 函数接口进行声明，例如，上面的宏定义声明可以展开成下面的形式：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;GL_ENTRY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;glReadPixels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLsizei&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLsizei&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLenum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLenum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pixels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 展开后的形式如下所示，它实际上就是 OpenGL ES API 函数声明&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;glReadPixels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLsizei&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLsizei&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLenum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLenum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pixels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后，通过 entries.in 和 egl_entries.in 这两个文件，我们就可以得到 OpenGL ES 和 EGL 中的所有 API 函数接口的说明。&lt;/p&gt;

&lt;h4 id=&quot;332-surfaceflinger-初始化成员变量-megldisplay&quot;&gt;3.3.2 SurfaceFlinger 初始化成员变量 mEGLDisplay&lt;/h4&gt;
&lt;p&gt;在 SurfaceFlinger 类中有一个 EGLDisplay 类型的成员变量 mEGLDisplay，它是 EGL 中用来构建 OpenGL ES 渲染环境所需的参数。&lt;/p&gt;

&lt;p&gt;SurfaceFlinger 中调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;eglGetDisplay()&lt;/code&gt; 初始化 mEGLDisplay 的代码如下：
&lt;em&gt;/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SurfaceFlinger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ALOGI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;  &lt;span class=&quot;s&quot;&gt;&quot;SurfaceFlinger's main thread ready to run. &quot;&lt;/span&gt;
            &lt;span class=&quot;s&quot;&gt;&quot;Initializing graphics H/W...&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;status_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Autolock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mStateLock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// initialize EGL for the default display&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 调用 eglGetDisplay 函数获取默认的显示设备&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mEGLDisplay&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eglGetDisplay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EGL_DEFAULT_DISPLAY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;eglInitialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mEGLDisplay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;紧接着在 &lt;code class=&quot;highlighter-rouge&quot;&gt;eglGetDisplay()&lt;/code&gt; 中调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;egl_init_drivers()&lt;/code&gt;
&lt;em&gt;/frameworks/native/opengl/libs/EGL/eglApi.cpp&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;EGLDisplay&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;eglGetDisplay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EGLNativeDisplayType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 调用egl_init_drivers() 加载 OpenGL ES 库和 EGL 库&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;egl_init_drivers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EGL_FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EGL_BAD_PARAMETER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EGL_NO_DISPLAY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;EGLDisplay&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dpy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;egl_display_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getFromNativeDisplay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后，&lt;code class=&quot;highlighter-rouge&quot;&gt;egl_init_drivers()&lt;/code&gt; 函数中使用了 pthread_mutex_lock 上锁保护，继续调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;egl_init_drivers_locked()&lt;/code&gt; 函数
&lt;em&gt;/frameworks/native/opengl/libs/EGL/egl.cpp&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;EGLBoolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;egl_init_drivers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;EGLBoolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pthread_mutex_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sInitDriverMutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 使用了 pthread_mutex_lock 上锁保护，继续调用 egl_init_drivers_locked&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;egl_init_drivers_locked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pthread_mutex_unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sInitDriverMutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面就是对 &lt;code class=&quot;highlighter-rouge&quot;&gt;egl_init_drivers_locked()&lt;/code&gt; 函数进行一个分析：&lt;/p&gt;

&lt;p&gt;egl_init_drivers_locked() 函数代码如下所示：
&lt;em&gt;/frameworks/native/opengl/libs/EGL/egl.cpp&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//在该文件起始位置定义的全局变量&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;egl_connection_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gEGLImpl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 描述EGL实现内容的结构体对象&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;gl_hooks_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gHooks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// gl_hooks_t 是包含 OpenGL ES API 函数声明对应的函数指针结构体&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;gl_hooks_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gHooksNoContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pthread_key_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gGLWrapperKey&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EGLBoolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;egl_init_drivers_locked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sEarlyInitState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// initialized by static ctor. should be set here.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EGL_FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 得到 Loader 对象单例&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// get our driver loader&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Loader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Loader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//  gEGLImple 是一个全局变量，数据类型为 egl_connection_t 结构体类型&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// dynamically load our EGL implementation&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;egl_connection_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gEGLImpl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// cnx-&amp;gt;dso 本质上是一个 (void *)类型的指针，它指向的对象是 EGL 共享库打开之后的句柄&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dso&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
        &lt;span class=&quot;c1&quot;&gt;// &amp;gt;= 将cnx中的 hooks 数组中指向OpenGL ES API 函数指针结构体指的数组成员，用 gHooks 中的成员的地址去初始化&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//也就是说 gEGLImpl 中 hook 数组指向 gHooks 数组，最终指向同一个 OpenGL ES API 函数指针的实现&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cnx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hooks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;egl_connection_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLESv1_INDEX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gHooks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;egl_connection_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLESv1_INDEX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cnx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hooks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;egl_connection_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLESv2_INDEX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gHooks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;egl_connection_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLESv2_INDEX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// &amp;gt;= 最后通过loader对象的open函数开始加载 OpenGL ES 和 EGL wrapper 库&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cnx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dso&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dso&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EGL_TRUE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EGL_FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在这个函数中，有一个非常关键的 egl_connection_t 指针指向一个全局变量 gEGLImpl，当第一次初始化加载 OpenGL ES 实现库和 EGL 实现库时，还需要将 gEGLImpl 中的 hooks 数组中的两个指针指向一个全局的 gl_hooks_t 数组 gHooks（这就是两个指针钩子，最终初始化完成后将分别勾住 OpenGL ES 1.0 和 OpenGL ES 2.0 的实现库），接着调用 Loader 类的实例的 open() 函数完成从 OpenGL ES 实现库中完成符号解析工作。&lt;/p&gt;

&lt;h4 id=&quot;333-通过-loader-类加载和解析-opengl-es-库和-egl-库&quot;&gt;3.3.3 通过 Loader 类加载和解析 OpenGL ES 库和 EGL 库&lt;/h4&gt;

&lt;p&gt;Loader::open() 函数的代码如下所示：
&lt;em&gt;/frameworks/native/opengl/libs/EGL/Loader.cpp&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// &amp;gt;= Loader 类对象构造完成后，就在 /EGL/egl.cpp 文件中的 egl_init_drivers_locked() 中被调用&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Loader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;egl_connection_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ATRACE_CALL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dso&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;driver_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hnd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;setEmulatorGlesValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;dso&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;load_driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;GLES&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EGL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLESv1_CM&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLESv2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dso&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;hnd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;driver_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dso&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Always load EGL first&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;dso&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;load_driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;EGL&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EGL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dso&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;hnd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;driver_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dso&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;hnd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;load_driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;GLESv1_CM&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLESv1_CM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLESv1_CM&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;hnd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;load_driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;GLESv2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;cnx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLESv2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;GLESv2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;LOG_ALWAYS_FATAL_IF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;couldn't find an OpenGL ES implementation&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;cnx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libEgl&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;load_wrapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EGL_WRAPPER_DIR&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/libEGL.so&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cnx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libGles2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;load_wrapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EGL_WRAPPER_DIR&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/libGLESv2.so&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cnx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libGles1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;load_wrapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EGL_WRAPPER_DIR&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/libGLESv1_CM.so&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;LOG_ALWAYS_FATAL_IF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libEgl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;s&quot;&gt;&quot;couldn't load system EGL wrapper libraries&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;LOG_ALWAYS_FATAL_IF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libGles2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libGles1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;s&quot;&gt;&quot;couldn't load system OpenGL ES wrapper libraries&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;open()&lt;/code&gt; 函数主要负责 OpenGL ES 库加载前的准备工作，具体的加载细节，则是通过调用 load_driver() 去完成的。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Loader::load_driver()&lt;/code&gt; 函数代码如下所示：
&lt;em&gt;/frameworks/native/opengl/libs/EGL/Loader.cpp&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Loader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load_driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                          &lt;span class=&quot;n&quot;&gt;egl_connection_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ATRACE_CALL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dso&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mGetDriverNamespace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;android_namespace_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mGetDriverNamespace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;dso&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;load_updated_driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//加载 OpenGL ES 实现库，放回打开的共享链接库的句柄&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dso&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;dso&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;load_system_driver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dso&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 解析 EGL 库，并将wrapper 库 libEGL.so 中的函数 API 指针和具体的实现绑定在一起&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EGL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;getProcAddress&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getProcAddressType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dlsym&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dso&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;eglGetProcAddress&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;ALOGE_IF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getProcAddress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                 &lt;span class=&quot;s&quot;&gt;&quot;can't find eglGetProcAddress() in EGL driver library&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;egl_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;egl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;egl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//将 egl 指针指向描述当前系统支持 OpenGL ES和 EGL 全局变量的 gEGLImpl&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;__eglMustCastToProperFunctionPointerType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__eglMustCastToProperFunctionPointerType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;egl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;api&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;egl_names&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//egl_names 是定义在 egl.cpp 文件中的一个数组，数组中的元素是 EGL API 函数指针&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;api&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;api&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;__eglMustCastToProperFunctionPointerType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__eglMustCastToProperFunctionPointerType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dlsym&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dso&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// couldn't find the entry-point, use eglGetProcAddress()&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getProcAddress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__eglMustCastToProperFunctionPointerType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//这一步就是最关键的将共享链接库中的 EGL API 的实现和上层调用的 API 函数指针绑定在一起&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;api&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//指向下一个需要绑定的 api 函数&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 解析 OpenGL ES 库中的 OpenGL ES 1.x API 符号&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLESv1_CM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 调用 init_api 实现 OpenGL API 和对应实现函数的绑定&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;init_api&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dso&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gl_names&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// gl_names 是定义在 egl.cpp 文件中的一个数组，数组中的元素是 OpenGL ES API 函数指针&lt;/span&gt;
                 &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__eglMustCastToProperFunctionPointerType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                 &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hooks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;egl_connection_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLESv1_INDEX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//gl成员变量是一个结构体变量，结构体中的是 OpenGL ES API 函数指针&lt;/span&gt;
                 &lt;span class=&quot;n&quot;&gt;getProcAddress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 解析 OpenGL ES 库中的 OpenGL ES 2.0 API 符号&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GLESv2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;init_api&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dso&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gl_names&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                 &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__eglMustCastToProperFunctionPointerType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                 &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hooks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;egl_connection_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GLESv2_INDEX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                 &lt;span class=&quot;n&quot;&gt;getProcAddress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dso&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Loader::load_driver()&lt;/code&gt; 它主要实现了两个功能：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;load_system_driver() &lt;/code&gt; 函数查找 OpenGL ES/EGL 实现库，并在指定的存放路径中找到共享链接库文件并打开它。&lt;/li&gt;
  &lt;li&gt;调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;init_api()&lt;/code&gt;解析打开的 OpenGL ES/EGL 共享链接库，将 OpenGL ES/EGL API 函数指针和共享链接库中实现的对应的函数符号绑定在一起，这样调用 OpenGL ES/EGL API 就会调用到具体实现的OpenGL ES/EGL 共享链接库中对应函数。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体 &lt;code class=&quot;highlighter-rouge&quot;&gt;load_system_driver()&lt;/code&gt; 函数和 &lt;code class=&quot;highlighter-rouge&quot;&gt;init_api()&lt;/code&gt; 函数的实现就不一一展开了，大家可以到 &lt;em&gt;/frameworks/native/opengl/libs/EGL/Loader.cpp&lt;/em&gt; 文件中查看，应该写得非常直接清楚了。&lt;/p&gt;

&lt;h3 id=&quot;34-小结&quot;&gt;3.4 &lt;strong&gt;小结&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;至此，有关 OpenGL ES/EGL 库的加载和解析过程就分析完了，&lt;strong&gt;整个加载和解析的目的就是将 OpenGL ES/EGL API 和具体实现函数绑定在一起&lt;/strong&gt;，这样当程序调用 OpenGL ES/EGL API 时，就会调用到实际的实现函数了。然后，在硬件平台上的 Android 系统加载的是硬件厂商提供的 OpenGL ES/EGL 实现库，而在 qemu 模拟器中运行的 Android 系统中加载的则是软件模拟实现的 
OpenGL ES/EGL 库或者是将 OpenGL ES 重定向到主机系统中进行硬件加速的库。&lt;/p&gt;

&lt;h3 id=&quot;35-参考文章&quot;&gt;3.5 参考文章&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.2net.co.uk/tutorial/android-egl-cgf-is-dead&quot;&gt;How Android finds OpenGL libraries, and the death of egl.cfg&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Tue, 05 Sep 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/android/2017/09/05/Android%E7%B3%BB%E7%BB%9F%E5%9B%BE%E5%BD%A2%E6%A0%88OpenGLES%E5%92%8CEGL%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.html</link>
        <guid isPermaLink="true">http://localhost:4000/android/2017/09/05/Android%E7%B3%BB%E7%BB%9F%E5%9B%BE%E5%BD%A2%E6%A0%88OpenGLES%E5%92%8CEGL%E5%BA%93%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.html</guid>
        
        <category>Android</category>
        
        <category>OpenGLES</category>
        
        <category>EGL</category>
        
        <category>Graphic</category>
        
        
        <category>android</category>
        
      </item>
    
      <item>
        <title>Android 系统图形栈（一）： OpenGL ES 和 EGL 介绍</title>
        <description>&lt;h2 id=&quot;opengl-es&quot;&gt;OpenGL ES&lt;/h2&gt;

&lt;h3 id=&quot;什么是-opengl-es&quot;&gt;什么是 OpenGL ES？&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;OpenGL ES（OpenGL for Embedded Systems）是 OpenGL 三维图形API的子集，针对手机、PDA和游戏主机等嵌入式设备而设计，各显卡制造商和系统制造商来实现这组 API。&lt;sup id=&quot;fnref:footnote_1&quot;&gt;&lt;a href=&quot;#fn:footnote_1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;opengl-基本概念&quot;&gt;OpenGL 基本概念&lt;/h3&gt;

&lt;p&gt;因为 OpenGL ES 是 OpenGL 的一个子集，所以下面就主要介绍一些有关 OpenGL 的一些基本概念。&lt;/p&gt;

&lt;p&gt;OpenGL 的结构可以从逻辑上划分为下面 3 个部分：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;图元&lt;/strong&gt;（Primitives）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;缓冲区&lt;/strong&gt;（Buffers）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;光栅化&lt;/strong&gt;（Rasterize）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;图元primitives&quot;&gt;图元（Primitives）&lt;/h4&gt;

&lt;p&gt;在 OpenGL 的世界里，我们只能画&lt;strong&gt;点、线、三角形&lt;/strong&gt;这三种基本图形，而其它复杂的图形都可以通过三角形来组成。所以这里的图元指的就是这三种基础图形：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;点&lt;/strong&gt;：点存在于三维空间，坐标用（x,y,z）表示。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;线&lt;/strong&gt;：由两个三维空间中的点组成。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;三角形&lt;/strong&gt;：由三个三维空间的点组成。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;缓冲区buffers&quot;&gt;缓冲区（Buffers）&lt;/h4&gt;

&lt;p&gt;OpenGL 中主要有 3 种 Buffer：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;帧缓冲区&lt;/strong&gt;（Frame Buffers）
  帧缓冲区：这个是存储&lt;strong&gt;OpenGL 最终渲染输出结果的地方&lt;/strong&gt;，它是一个包含多个图像的集合，例如颜色图像、深度图像、模板图像等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;渲染缓冲区&lt;/strong&gt;（Render Buffers）
  渲染缓冲区：渲染缓冲区就是一个图像，它是 Frame Buffer 的一个子集。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;缓冲区对象&lt;/strong&gt;（Buffer Objects）
  缓冲区对象就是程序员输入到 OpenGL 的数据，分为结构类和索引类的。前者被称为“数组缓冲区对象”或“顶点缓冲区对象”（“Array Buffer Object”或“Vertex Buff
er Object”），即用来描述模型的数组，如顶点数组、纹理数组等； 后者被称为“索引缓冲区对象”（“Index Buffer Object”），是对上述数组的索引。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;光栅化rasterize&quot;&gt;光栅化（Rasterize）&lt;/h4&gt;

&lt;p&gt;在介绍光栅化之前，首先来补充 OpenGL 中的两个非常重要的概念：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Vertex
  Vertex 就是图形中顶点，一系列的顶点就围成了一个图形。&lt;/li&gt;
  &lt;li&gt;Fragment
  Fragment 是三维空间的点、线、三角形这些基本图元映射到二维平面上的映射区域，通常一个 Fragment 对应于屏幕上的一个像素，但高分辨率的屏幕可能会用多个像素点映射到一个 Fragment，以减少 GPU 的工作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而&lt;strong&gt;光栅化&lt;/strong&gt;是把点、线、三角形映射到屏幕上的像素点的过程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://picturebed.obs.cn-east-2.myhuaweicloud.com/blogPictures/20170904150453148671075.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;着色器程序shader&quot;&gt;着色器程序（Shader）&lt;/h4&gt;

&lt;p&gt;Shader 用来描述如何绘制（渲染），GLSL 是 OpenGL 的编程语言，全称 OpenGL Shader Language，它的语法类似于 C 语言。OpenGL 渲染需要两种 Shader：Vertex Shader 和 Fragment Shader。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Vertex Shader
  Vertex Shader 对于3D模型网格的每个顶点执行一次，主要是确定该顶点的最终位置。&lt;/li&gt;
  &lt;li&gt;Fragment Shader
  Fragment Shader对光栅化之后2D图像中的每个像素处理一次。3D物体的表面最终显示成什么样将由它决定，例如为模型的可见表面添加纹理，处理光照、阴影的影响等等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;opengl-流水线&quot;&gt;OpenGL 流水线&lt;/h4&gt;

&lt;p&gt;OpenGL 中有两种流水线，一种是固定流水线，另外一种则是可编程流水线。&lt;/p&gt;

&lt;p&gt;其中，OpenGL 1.0 版本支持固定流水线。其结构如下图所示：
&lt;img src=&quot;https://picturebed.obs.cn-east-2.myhuaweicloud.com/blogPictures/opengles_1x_pipeline.gif&quot; alt=&quot;OpenGL 1.0 固定流水线&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从OpenGL 2.0版本开始，OpenGL支持可编程的流水线。也就是说，程序员可以通过Shader（一种程序）来控制GPU渲染的过程。
&lt;img src=&quot;https://picturebed.obs.cn-east-2.myhuaweicloud.com/blogPictures/opengles_20_pipeline2.gif&quot; alt=&quot;OpenGL 2.0 可编程流水线&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;egl&quot;&gt;EGL&lt;/h2&gt;

&lt;h3 id=&quot;什么是-egl&quot;&gt;什么是 EGL？&lt;/h3&gt;

&lt;p&gt;EGL 是 OpenGL ES 渲染 API 和本地窗口系统(native platform window system)之间的一个中间接口层，它主要由系统制造商实现。EGL提供如下机制：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;与设备的原生窗口系统通信&lt;/li&gt;
  &lt;li&gt;查询绘图表面的可用类型和配置&lt;/li&gt;
  &lt;li&gt;创建绘图表面&lt;/li&gt;
  &lt;li&gt;在OpenGL ES 和其他图形渲染API之间同步渲染&lt;/li&gt;
  &lt;li&gt;管理纹理贴图等渲染资源&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了让OpenGL ES能够绘制在当前设备上，我们需要EGL作为OpenGL ES与设备的&lt;strong&gt;桥梁&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;使用-egl-绘图的基本步骤&quot;&gt;使用 EGL 绘图的基本步骤&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://picturebed.obs.cn-east-2.myhuaweicloud.com/blogPictures/15038887630772.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Display(EGLDisplay) 是对实际显示设备的抽象。&lt;/li&gt;
  &lt;li&gt;Surface（EGLSurface）是对用来存储图像的内存区域&lt;/li&gt;
  &lt;li&gt;FrameBuffer 的抽象，包括 Color Buffer， Stencil Buffer ，Depth Buffer。Context (EGLContext) 存储 OpenGL ES绘图的一些状态信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用EGL的绘图的一般步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;获取 EGL Display 对象：eglGetDisplay()&lt;/li&gt;
  &lt;li&gt;初始化与 EGLDisplay 之间的连接：eglInitialize()&lt;/li&gt;
  &lt;li&gt;获取 EGLConfig 对象：eglChooseConfig()&lt;/li&gt;
  &lt;li&gt;创建 EGLContext 实例：eglCreateContext()&lt;/li&gt;
  &lt;li&gt;创建 EGLSurface 实例：eglCreateWindowSurface()&lt;/li&gt;
  &lt;li&gt;连接 EGLContext 和 EGLSurface：eglMakeCurrent()&lt;/li&gt;
  &lt;li&gt;使用 OpenGL ES API 绘制图形：gl_*()&lt;/li&gt;
  &lt;li&gt;切换 front buffer 和 back buffer 送显：eglSwapBuffer()&lt;/li&gt;
  &lt;li&gt;断开并释放与 EGLSurface 关联的 EGLContext 对象：eglRelease()&lt;/li&gt;
  &lt;li&gt;删除 EGLSurface 对象&lt;/li&gt;
  &lt;li&gt;删除 EGLContext 对象&lt;/li&gt;
  &lt;li&gt;终止与 EGLDisplay 之间的连接&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;opengl-es-和-egl-的联系&quot;&gt;OpenGL ES 和 EGL 的联系&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://picturebed.obs.cn-east-2.myhuaweicloud.com/blogPictures/20170904150453844639965.png&quot; alt=&quot;20170904150453844639965.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;一个类比的例子&quot;&gt;一个类比的例子&lt;/h3&gt;

&lt;p&gt;我们来思考一下画家绘画的过程：首先要有一名懂得各种绘画技艺的画家，然后他需要一张画布，一些笔，一些颜料，一些辅助工具（尺、模板、橡皮、调色板等等），然后他在画布上绘制第一幅画，完成之后展示给人们看；在人们观赏第一幅画的时候，他可以在第二张画布上绘制第二幅画，绘制完成后收回第一幅画，将第二幅画展现给人们看；接着使用工具擦除第一幅画，在同一张画布上绘制第三幅画；周而复始，人们便看到了一幅接一幅的画。&lt;/p&gt;

&lt;p&gt;对比 OpenGL ES/EGL，各要素的对应关系大体如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;画家：编程人员&lt;/li&gt;
  &lt;li&gt;笔、颜料、辅助工具：OpenGL ES API&lt;/li&gt;
  &lt;li&gt;画布：EGL 创建的 Surface&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以计算机绘画的本质就是选择图像显示的像素格式，申请一块内存（画布），填充像素（颜色），绘制完成之后，通知计算机显示到屏幕上（按比例发射RGB光），最终就看到了所绘制的画面。之所以要先选择像素格式，是因为无论是所申请内存的大小，还是硬件驱动解析这块内存的方式，都是由像素格式决定的。&lt;/p&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.khronos.org/egl&quot;&gt;EGL 的官方介绍说明&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.slideshare.net/SuhanLee2/understaing-android-egl&quot;&gt;Understaing Android EGL&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.piasy.com/2016/06/07/Open-gl-es-android-2-part-1/&quot;&gt;安卓 OpenGL ES 2.0 完全入门（一）：基本概念和 hello world&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/kiffa/archive/2013/02/21/2920106.html&quot;&gt;EGL 参考资料1: 学习OpenGL-ES: 1 - 像素、颜色、显存、初始化&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/kiffa/archive/2013/02/21/2921123.html&quot;&gt;EGL 参考资料2: 学习OpenGL-ES: 2 - EGL解析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://mobile.51cto.com/app-show-436809.htm&quot;&gt;OpenGL ES 2.0 编程三步曲&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/kiffa/archive/2013/02/22/2922487.html&quot;&gt;OpenGL 参考资料1: 学习OpenGL-ES: 3 - 3D绘图原理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/hrlnw/p/4642272.html&quot;&gt;Android OpenGL ES 离屏渲染（offscreen render）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.shengbin.me/posts/opengl-concepts/&quot;&gt;OpenGL基本概念&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.db-in.com/all-about-opengl-es-2-x-part-1/&quot;&gt;All about OpenGL ES 2.x - (part 1/3)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.db-in.com/all-about-opengl-es-2-x-part-2/&quot;&gt;All about OpenGL ES 2.x - (part 2/3)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.db-in.com/all-about-opengl-es-2-x-part-3/&quot;&gt;All about OpenGL ES 2.x - (part 3/3)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://wiki.jikexueyuan.com/project/opengl-es-guide/about-egl.html&quot;&gt;关于EGL&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:footnote_1&quot;&gt;
      &lt;p&gt;https://zh.wikipedia.org/wiki/OpenGL_ES &lt;a href=&quot;#fnref:footnote_1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 04 Sep 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/android/2017/09/04/Android%E7%B3%BB%E7%BB%9F%E5%9B%BE%E5%BD%A2%E6%A0%88OpenGLES%E5%92%8CEGL%E4%BB%8B%E7%BB%8D.html</link>
        <guid isPermaLink="true">http://localhost:4000/android/2017/09/04/Android%E7%B3%BB%E7%BB%9F%E5%9B%BE%E5%BD%A2%E6%A0%88OpenGLES%E5%92%8CEGL%E4%BB%8B%E7%BB%8D.html</guid>
        
        <category>Android</category>
        
        <category>Graphic</category>
        
        <category>OpenGLES</category>
        
        <category>EGL</category>
        
        
        <category>android</category>
        
      </item>
    
      <item>
        <title>Linux I/O 模型详解</title>
        <description>&lt;h1 id=&quot;linux-io-模型&quot;&gt;Linux I/O 模型&lt;/h1&gt;
&lt;p&gt;在 Linux/Unix 系统环境下进行 I/O 编程时，我们经常会遇到这些似懂非懂的名词：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Synchronous I/O&lt;/li&gt;
  &lt;li&gt;Asynchronous I/O&lt;/li&gt;
  &lt;li&gt;Blocking I/O&lt;/li&gt;
  &lt;li&gt;Non-blocking I/O&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;首先，这里讲的 &lt;strong&gt;I/O&lt;/strong&gt; 指的是用户空间的 I/O，并且主要侧重于网络编程中的 I/O 操作，而用户空间的 I/O 操作主要分为两个阶段：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;等待数据准备就绪（waiting for the data to be ready）&lt;/li&gt;
  &lt;li&gt;将数据从内核拷贝到进程中（copying the data from kernel to the process）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;正是因为这两个阶段，Linux 系统中的 I/O 模型主要可以分为下面五种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Blocking I/O&lt;/li&gt;
  &lt;li&gt;Non-blocking I/O&lt;/li&gt;
  &lt;li&gt;I/O multiplexing&lt;/li&gt;
  &lt;li&gt;Asynchronous I/O&lt;/li&gt;
  &lt;li&gt;Signal driven I/O&lt;/li&gt;
&lt;/ul&gt;

&lt;!--more--&gt;

&lt;h1 id=&quot;blocking-io&quot;&gt;Blocking I/O&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://picturebed.obs.cn-east-2.myhuaweicloud.com/blogPictures/15003778419199.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在 Linux 中所有的 socket 文件描述符默认都是 blocking 的，一个典型的网络 socket 文件描述符的 read 操作的流程如上图所示。&lt;/p&gt;

&lt;p&gt;当用户进程调用 read 这个系统调用，kernel 就开始了 &lt;strong&gt;I/O&lt;/strong&gt; 的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候 kernel 就要等待足够的数据到来），这个过程需要等待，也就是说&lt;strong&gt;数据被拷贝到操作系统内核的缓冲区&lt;/strong&gt;中是需要一个过程的。&lt;/p&gt;

&lt;p&gt;而在用户进程这边，整个进程一直处于阻塞状态。当 kernel 中数据准备好之后，系统就会将数据从 kernel 中拷贝到用户空间进程的缓冲区中，然后 kernel 返回结果，用户进程才解除 blocking 的状态，重新运行起来。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;blocking I/O 的特点是用户进程在 I/O 操作的两个阶段都被 block 了。&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;non-blocking-io&quot;&gt;Non-blocking I/O&lt;/h1&gt;
&lt;p&gt;Linux 系统中可以在调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;open&lt;/code&gt; 函数打开 socket 文件时或者调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;fcntl&lt;/code&gt; 函数来设置 socket 文件描述符为非阻塞状态，当对一个 non-blocking 的 socket 文件描述符执行读操作时，它的执行流程如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://picturebed.obs.cn-east-2.myhuaweicloud.com/blogPictures/15003788703867.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在 non-blocking I/O 的情境下，当用户进程调用 read 系统调用函数时，如果 kernel 中的数据没有准备好，那么系统并不会 block 用户进程，而是立即返回一个 error。&lt;/p&gt;

&lt;p&gt;从用户进程角度看 ，当它发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送read操作。&lt;/p&gt;

&lt;p&gt;一旦 kernel 中的数据准备好之后，并且再次收到了用户进程发送的 read 系统调用时，它就马上将准备好的数据拷贝到用户空间的缓冲区中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;non-blocking I/O 的特点就是用户进程需要不断地询问 kernel 数据是否准备好了。&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;io-multiplexing&quot;&gt;I/O Multiplexing&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;I/O multiplexing&lt;/code&gt; 就是我们经常说的 &lt;strong&gt;select&lt;/strong&gt;、&lt;strong&gt;poll&lt;/strong&gt;和&lt;strong&gt;epoll&lt;/strong&gt;，有些地方也称这种 I/O 方式为 &lt;code class=&quot;highlighter-rouge&quot;&gt;event driven I/O&lt;/code&gt;。I/O multiplexing 的好处就是一个进程可以处理多个网络连接 I/O，它的工作原理就是 select/poll/epoll 函数会不断的查询所监测的 socket 文件描述符中是否有 socket 准备好读写了，如果有，那么系统就会通知用户进程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://picturebed.obs.cn-east-2.myhuaweicloud.com/blogPictures/15003804947449.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;I/O multiplexing 的特点是通过一种机制让一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入可读的就绪状态，select/poll/epoll函数就可以立即返回。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个图和 &lt;code class=&quot;highlighter-rouge&quot;&gt;blocking I/O&lt;/code&gt; 的图其实并没有太大的不同，事实上，开销还会更大一点。因为这里需要使用两个 system call (select 和 read)，而 blocking I/O 只调用了一个system call (read)。但是，&lt;strong&gt;用 select 的优势在于它可以同时处理多个connection&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;所以，如果处理的连接数不是很高的话，使用 &lt;strong&gt;select/epoll&lt;/strong&gt; 的 web server 不一定比使用 &lt;strong&gt;multi-threading + blocking I/O&lt;/strong&gt; 的 web server 性能更好，可能延迟还更大。&lt;strong&gt;select/epoll&lt;/strong&gt;的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。&lt;/p&gt;

&lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;I/O multiplexing&lt;/code&gt; 模型中，实际中，对于每一个 socket，一般都设置成为 non-blocking，但是，如上图所示，整个用户的process 其实是一直被 block 的。只不过用户进程是被 select 这个函数 block，而不是被 socket I/O 给 block。&lt;/p&gt;

&lt;h1 id=&quot;signal-driven-io&quot;&gt;Signal Driven I/O&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://picturebed.obs.cn-east-2.myhuaweicloud.com/blogPictures/15003812004927.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Signal Driven I/O&lt;/strong&gt; 的工作原理就是用户进程首先和 kernel 之间建立信号的通知机制，即用户进程告诉 kernel，如果 kernel 中数据准备好了，就通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;SIGIO&lt;/code&gt; 信号通知我。然后用户空间的进程就会调用 read 系统调用将准备好的数据从 kernel 拷贝到用户空间。&lt;/p&gt;

&lt;p&gt;但是这种 I/O 模型存在一个非常重大的&lt;strong&gt;缺陷问题&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;SIGIO&lt;/code&gt; 这种信号对于每个进程来说只有一个！如果使该信号对进程中的两个描述符（这两个文件描述符都等待着 I/O 操作）都起作用，那么进程在接到此信号后就无法判别是哪一个文件描述符准备好了。所以 &lt;strong&gt;Signal Driven I/O&lt;/strong&gt; 模型在现实中用的非常少。&lt;/p&gt;

&lt;h1 id=&quot;asynchronous-io&quot;&gt;Asynchronous I/O&lt;/h1&gt;
&lt;p&gt;Linux 系统中 Asynchronous I/O 的操作流程如下图所示：
&lt;img src=&quot;https://picturebed.obs.cn-east-2.myhuaweicloud.com/blogPictures/15003826926363.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用户进程通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;aio_read()&lt;/code&gt; 函数进行读取操作时，就可以立刻返回到进程中，接着执行其他的操作。从 kernel 的角度来看，当它收到 &lt;strong&gt;asynchronous read&lt;/strong&gt;  操作时，它会立刻返回，并不会阻塞用户进程。然后，kernel 会等待数据准备完成，接着将数据拷贝到用户空间进程的缓冲区中。当这一切都完成之后，kernel 会给用户发送一个 signal 通知用户空间的进程，告诉它 read 操作完成了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Asynchronous I/O 操作最大的特点就是整个 I/O 操作流程中，用户进程始终没有被 block。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在 POSIX 异步 I/O 中，会有一个 &lt;strong&gt;struct aiocb&lt;/strong&gt; 结构体来描述异步 I/O 操作，这个结构体的定义如下所示：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aiocb&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;             &lt;span class=&quot;n&quot;&gt;aio_fildes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* file descriptor */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;off_t&lt;/span&gt;           &lt;span class=&quot;n&quot;&gt;aio_offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* file offset for I/O */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;aio_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* buffer for I/O */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;          &lt;span class=&quot;n&quot;&gt;aio_nbytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* number of bytes to transfer */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;             &lt;span class=&quot;n&quot;&gt;aio_reqprio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* priority */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sigevent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aio_sigevent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* signal infomation */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;             &lt;span class=&quot;n&quot;&gt;aio_lio_opcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* operation for list I/O */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个 POSIX 异步 I/O 控制块结构体描述了，异步 I/O 操作对应的文件描述符，用户空间的进程存放读/写的数据的缓冲区，以及异步 I/O 操作完成之后，对接收到信号的处理结构体等等。&lt;/p&gt;

&lt;h1 id=&quot;synchronous-io-和-asynchronous-io-的区别&quot;&gt;Synchronous I/O 和 Asynchronous I/O 的区别&lt;/h1&gt;

&lt;p&gt;在说明 &lt;strong&gt;Synchronous I/O&lt;/strong&gt; 和 &lt;strong&gt;Asynchronous I/O&lt;/strong&gt; 的区别之前，需要先给出两者的定义，POSIX 中两者的定义是这样子的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;&lt;/li&gt;
  &lt;li&gt;An asynchronous I/O operation does not cause the requesting process to be blocked;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;两者的区别就在于 Synchronous I/O 做 &lt;code class=&quot;highlighter-rouge&quot;&gt;IO operation&lt;/code&gt; 的时候会将用户空间的进程阻塞。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;按照这个定义，之前所说的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Blocking I/O&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;Non-blocking I/O&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;IO multiplexing&lt;/code&gt;都属于 &lt;strong&gt;Synchronous I/O&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;有人会说，&lt;code class=&quot;highlighter-rouge&quot;&gt;Non-blocking I/O&lt;/code&gt; 并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的 &lt;code class=&quot;highlighter-rouge&quot;&gt;IO operation&lt;/code&gt; 是指&lt;strong&gt;真实的I/O操作&lt;/strong&gt;，就是例子中的 read 这个 system call。&lt;code class=&quot;highlighter-rouge&quot;&gt;Non-blocking I/O&lt;/code&gt; 在执行 read 这个system call 的时候，如果 kernel 的数据没有准备好，这时候不会 block 进程。但是，当kernel 中数据准备好的时候，read 会将数据从kernel 拷贝到用户空间的缓冲区中，这个时候进程是被 block 的。&lt;/p&gt;

&lt;p&gt;而&lt;strong&gt;Asynchronous I/O&lt;/strong&gt;则不一样，当进程发起 &lt;strong&gt;I/O&lt;/strong&gt; 操作之后，就直接返回再也不理睬了，直到 kernel 发送一个信号，告诉进程说 I/O完成。在这整个过程中，&lt;strong&gt;进程完全没有被 block&lt;/strong&gt;。&lt;/p&gt;

</description>
        <pubDate>Tue, 11 Jul 2017 03:55:24 +0800</pubDate>
        <link>http://localhost:4000/linux/2017/07/11/Linux-IO%E6%A8%A1%E5%9E%8B.html</link>
        <guid isPermaLink="true">http://localhost:4000/linux/2017/07/11/Linux-IO%E6%A8%A1%E5%9E%8B.html</guid>
        
        <category>Linux</category>
        
        <category>Unix</category>
        
        <category>I/O</category>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>Linux 内核加载启动过程分析</title>
        <description>&lt;p&gt;本文是基于 &lt;code class=&quot;highlighter-rouge&quot;&gt;Linux Kernel 4.4.49&lt;/code&gt; 版本内核源码中的 x86 32 位体系结构进行分析。&lt;/p&gt;

&lt;h1 id=&quot;bios-传统模式下的-x86-pc-启动过程&quot;&gt;BIOS 传统模式下的 X86 PC 启动过程&lt;/h1&gt;

&lt;h2 id=&quot;什么是-bios&quot;&gt;什么是 BIOS？&lt;/h2&gt;
&lt;p&gt;简单来说 BIOS 也是一段程序代码，但是它比较特殊，它是 CPU 启动后执行的第一段代码，存储在 PC 设备中的只读存储器（ROM）中，主要完成检测内存、显卡等一系列硬件设备和建立中断向量表（IVT，Interrupt Vector Table）的工作。&lt;/p&gt;

&lt;p&gt;ROM 其实也一块内存，它会被映射到 CPU 实模式下所能访问的 1MB 物理内存空间的顶部，即地址 &lt;code class=&quot;highlighter-rouge&quot;&gt;0xF000:0000 ~ 0xF000:FFFF&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在这里补充一下， X86 处理器有两种运行模式一种是实模式，另外一种是保护模式，它们两者之间最主要的区别就是：实模式下 CPU 访问内存的地址采用的是&lt;strong&gt;分段&lt;/strong&gt;方式（也就是&lt;strong&gt;段基址：段内便宜&lt;/strong&gt;），生成的是可以直接访问物理内存的&lt;strong&gt;物理地址&lt;/strong&gt;，而保护模式下 CPU 访问内存的地址采用的是&lt;strong&gt;分页&lt;/strong&gt;方式，生成的是&lt;strong&gt;虚拟地址&lt;/strong&gt;，不能直接访问物理内存，需要通过 &lt;strong&gt;MMU&lt;/strong&gt; 硬件将虚拟地址转换为物理地址后才能访问物理内存。&lt;/p&gt;

&lt;p&gt;X86 实模式下物理内存映射空间结构如下图所示：
&lt;img src=&quot;https://picturebed.obs.cn-east-2.myhuaweicloud.com/blogPictures/14983994852650.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;bios-启动过程&quot;&gt;BIOS 启动过程&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;当 X86 架构的 PC 在开机上电的一瞬间，CPU 中的 &lt;strong&gt;CS&lt;/strong&gt; 和 &lt;strong&gt;IP&lt;/strong&gt; 寄存器就被设置成了 &lt;code class=&quot;highlighter-rouge&quot;&gt;0xF000:FFF0&lt;/code&gt;（这个地址就是 BIOS 代码所在内存区域），这个地址指向了 CPU 执行第一条指令的位置。而在这个地址里只存放了一条非常简单的跳转指令 &lt;code class=&quot;highlighter-rouge&quot;&gt;jmp far f000:e05b&lt;/code&gt;，然后程序就跳转到了 BIOS 代码中的另外一个地址 &lt;code class=&quot;highlighter-rouge&quot;&gt;f000:e05b&lt;/code&gt; 处开始接着往下执行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;接下来，BIOS 就马不停蹄地检测内存、显卡等外设信息，当硬件检测通过之后，就在内存的物理内存的起始位置 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x000 ~ 0x3FF&lt;/code&gt; （刚好 1KB 的内存空间)建立中断向量表（IVT），如上图物理内存最底部的所示。&lt;/p&gt;

    &lt;p&gt;x86 中断向量表中有 256 个中断向量，每个中断向量用 4 个字节来表示（CS 用两个字节表示，IP 也用两个字节表示），通过中断向量中保存的 &lt;code class=&quot;highlighter-rouge&quot;&gt;CS:IP&lt;/code&gt; 地址就可以跳转到对应的中断处理程序去处理中断请求信号。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最后，BIOS 将&lt;strong&gt;启动磁盘&lt;/strong&gt;中的第 1 个扇区（MBR 扇区，Master Boot Record）的 512 个字节的数据加载到物理内存地址为 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x7C00 ~ 0x7E00&lt;/code&gt; 的区域，然后程序就跳转到 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x7C00&lt;/code&gt; 处开始执行，至此，BIOS 就完成了所有的工作，将控制权转交到了 MBR 中的代码。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;mbr-扇区&quot;&gt;MBR 扇区&lt;/h2&gt;
&lt;p&gt;MBR（Master Boot Record）扇区是启动磁盘中的第 1 个扇区，它主要由三部分组成：第一部分是一段引导程序，主要用来加载启动内核所需 Bootloader 程序；第二部分是当前启动磁盘的分区表；第三部分是标识 MBR 扇区的魔数 &lt;strong&gt;0x55&lt;/strong&gt; 和 &lt;strong&gt;0xAA&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;MBR 分区组成结构如下图所示：
&lt;img src=&quot;https://picturebed.obs.cn-east-2.myhuaweicloud.com/blogPictures/14984029056904.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;bootloader-加载程序&quot;&gt;Bootloader 加载程序&lt;/h2&gt;
&lt;p&gt;Bootloader 是一段用来将 Linux Kernel 镜像文件加载到物理内存中指定地址的程序，这里所指的 Bootloader 是广义上概念，其实它还可以细分成两个独立的 bootloader：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;第一个 bootloader&lt;/strong&gt;：由 MBR 扇区中的前 446 个字节构成，作用是找到第二个 bootloader 并将其加载到物理内存中，并跳转到第二个 bootloader 中执行。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;第二个 bootloader&lt;/strong&gt;：这个 bootloader 位于启动盘中 MBR 扇区之后，根据 bootloader 代码的大小可能会占用一个或多个磁盘分区，它的主要作用就是找到磁盘中存放的 Linux Kernel 镜像文件以及 initrd 文件（如果在内核命令行参数中指定了的话），并将其加载到物理内存当中。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;注：initrd 是 initialized ram disk 的意思。主要用于加载硬件驱动模块，辅助内核的启动，挂载真正的根文件系统。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上述这两个 bootloader 程序合在一起就构成了我们在 Linux 系统中经常用到的两个 Bootloader 程序，LILO（Linux Loader）或者是 GRUB（Grand Unified Boot Loader）。&lt;/p&gt;

&lt;p&gt;GRUB 是我们现在 Linux 发行版系统中最常用到的 Bootloader，它的&lt;strong&gt;优势在于它可以识别 Linux 文件系统&lt;/strong&gt;，例如 ext3，ext4 格式的文件系统。不像 LILO 只能从原始的磁盘扇区中加载 Linux Kernel 镜像，GRUB 可以从 ext3 或者 ext4 格式文件系统的磁盘分区中加载 Linux Kernel 镜像。&lt;/p&gt;

&lt;p&gt;总结一下 Bootloader 主要完成了下面几项工作：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从 MBR 扇区中的第一个 bootloader 程序跳转实际执行内核加载操作的第二个 bootloder 程序。&lt;/li&gt;
  &lt;li&gt;第二个 bootloder 程序查找 Linux Kernel 镜像在启动盘中的位置（要么存放磁盘中的固定位置，要么通过文件系统去解析）。&lt;/li&gt;
  &lt;li&gt;将找到的 Linux Kernel 镜像和 initrd 文件加载到物理内存中的指定地址处，并建立运行内核的所需的基本环境。&lt;/li&gt;
  &lt;li&gt;最后，Bootloader 就将控制权转交到 Linux 内核，然后由内核开始执行。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;x86 系统中 Bootloader 加载内核启动的过程，如下图所示：
&lt;img src=&quot;https://picturebed.obs.cn-east-2.myhuaweicloud.com/blogPictures/14984058448893.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;linux-kernel-镜像&quot;&gt;Linux Kernel 镜像&lt;/h1&gt;

&lt;h2 id=&quot;linux-kernel-镜像格式&quot;&gt;Linux Kernel 镜像格式&lt;/h2&gt;
&lt;p&gt;Linux 内核有多种格式的镜像，例如 vmlinux、Image、zImage、bzImage、uImage、xipImage、bootpImage 等。&lt;/p&gt;

&lt;h3 id=&quot;vmlinux&quot;&gt;vmlinux&lt;/h3&gt;
&lt;p&gt;vmlinux 是可引导的、未压缩、可压缩的内核镜像，vm 代表&lt;strong&gt;Virtual Memory&lt;/strong&gt;，Linux 支持虚拟内存，因此得名 vm。它是由用户对内核源码编译得到，实质是 ELF 格式的文件，也就是说vmlinux 是编译出来的最原始的内核文件，未被压缩过。&lt;/p&gt;

&lt;h3 id=&quot;image&quot;&gt;Image&lt;/h3&gt;
&lt;p&gt;Image是经过 &lt;strong&gt;objcopy&lt;/strong&gt; 处理的只包含二进制数据的内核代码，它已经不是 ELF 格式了，但这种格式的内核镜像还没有经过压缩。&lt;/p&gt;

&lt;p&gt;objcopy 工具的作用是拷贝一个目标文件的内容到另一个目标文件中，也就是说，可以将一种格式的目标文件转换成另一种格式的目标文件。通过使用 binary 作为输出目标(-o binary)，可产生一个原始的二进制文件，实质上是将所有的符号和重定位信息都将被抛弃，只剩下二进制数据。&lt;/p&gt;

&lt;h3 id=&quot;zimage&quot;&gt;zImage&lt;/h3&gt;
&lt;p&gt;zImage 是 ARM Linux 常用的一种压缩镜像文件，它是由vmlinux 加上&lt;strong&gt;解压代码&lt;/strong&gt;经 gzip 压缩而成，命令格式是 &lt;code class=&quot;highlighter-rouge&quot;&gt;make zImage&lt;/code&gt;，这种格式的 Linux 内核镜像文件多存放在 NAND Flash 上。&lt;/p&gt;

&lt;h3 id=&quot;bzimage&quot;&gt;bzImage&lt;/h3&gt;
&lt;p&gt;bzImage 不是用 bzip2 压缩的，&lt;strong&gt;bz 表示 big zImage&lt;/strong&gt;,其格式与 zImage 类似，但采用了不同的压缩算法，注意，bzImage 的压缩率更高是压缩的内核映像。&lt;/p&gt;

&lt;p&gt;zImage vs bzImage：它们不仅是一个压缩文件，而且在这两个文件的开头部分内嵌有解压缩代码。两者的&lt;strong&gt;不同之处&lt;/strong&gt;在于，老的&lt;strong&gt;zImage 解压缩内核到低端内存&lt;/strong&gt;(第一个 640K)，&lt;strong&gt;bzImage解压缩内核到高端内存(1M以上)&lt;/strong&gt;。如果内核比较小，那么可以采用 zImage 或 bzImage 之一，两种方式引导的系统运行时是相同的。大的内核采用 bzImage，不能采用 zImage。&lt;/p&gt;

&lt;h3 id=&quot;uimage&quot;&gt;uImage&lt;/h3&gt;
&lt;p&gt;uImage 是 uboot 专用的镜像文件，它是在 zImage 之前加上一个长度为&lt;strong&gt;0x40&lt;/strong&gt;的头信息(tag)，在头信息内说明了该镜像文件的类型、加载 位置、生成时间、大小等信息。换句话说，若直接从 uImage 的0x40位置开始执行，则 zImage 和 uImage 没有任何区别，命令格式是 &lt;code class=&quot;highlighter-rouge&quot;&gt;make uImage&lt;/code&gt;，这种格式的 Linux 镜像文件多存放在 NAND Flash 上。&lt;/p&gt;

&lt;h3 id=&quot;xipimage&quot;&gt;xipImage&lt;/h3&gt;
&lt;p&gt;这种格式的 Linux 镜像文件多存放在 NOR Flash 上，且运行时不需要拷贝到内存 SDRAM 中，可以直接在 NOR Flash 中运行。&lt;/p&gt;

&lt;p&gt;有关 NOR Flash 和 NAND Flash 的概念和区别可以参靠下面这篇文章：&lt;a href=&quot;http://blog.csdn.net/shuaishuai80/article/details/6202205&quot;&gt;NorFlash和NandFlash区别&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;linux-kernel-镜像生成过程&quot;&gt;Linux Kernel 镜像生成过程&lt;/h2&gt;
&lt;p&gt;一个可以被&lt;strong&gt;加载启动&lt;/strong&gt;的 Linux 内核镜像除了包含上面介绍的最基本的压缩或者未被压缩的编译好的 Linux Kernel 镜像目标文件之外，还包含一个文件头部分和末尾的CRC校验码部分，它的结构如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://picturebed.obs.cn-east-2.myhuaweicloud.com/blogPictures/Linux-kernel-boot-image.png&quot; alt=&quot;Linux-kernel-boot-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：如上图所示的内核镜像中，&lt;strong&gt;boot/setup.bin&lt;/strong&gt; 是实模式下执行的代码，&lt;strong&gt;boo/vmlinux.bin&lt;/strong&gt; 则是保护模式下执行的代码。&lt;/p&gt;

&lt;p&gt;例如，在内核从 &lt;strong&gt;vmlinux&lt;/strong&gt; 文件编译生成 &lt;strong&gt;bzImage&lt;/strong&gt; 内核镜像文件的过程如下所示：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MKPIGGY &lt;span class=&quot;nb&quot;&gt;arch&lt;/span&gt;/x86/boot/compressed/piggy.S
  AS      &lt;span class=&quot;nb&quot;&gt;arch&lt;/span&gt;/x86/boot/compressed/piggy.o &lt;span class=&quot;c&quot;&gt;# 编译 arch/x86/boot/compressed/piggy.S&lt;/span&gt;
  LD      &lt;span class=&quot;nb&quot;&gt;arch&lt;/span&gt;/x86/boot/compressed/vmlinux &lt;span class=&quot;c&quot;&gt;# 将 piggy.o 和 vmlinux 链接在一起生成 vmlinux.bin&lt;/span&gt;
  ZOFFSET &lt;span class=&quot;nb&quot;&gt;arch&lt;/span&gt;/x86/boot/zoffset.h
  OBJCOPY &lt;span class=&quot;nb&quot;&gt;arch&lt;/span&gt;/x86/boot/vmlinux.bin &lt;span class=&quot;c&quot;&gt;# 使用 objcopy 命令去除 vmlinux 中的符号表信息&lt;/span&gt;
  AS      &lt;span class=&quot;nb&quot;&gt;arch&lt;/span&gt;/x86/boot/header.o &lt;span class=&quot;c&quot;&gt;# 汇编 arch/x86/boot/header.S 文件&lt;/span&gt;
  LD      &lt;span class=&quot;nb&quot;&gt;arch&lt;/span&gt;/x86/boot/setup.elf &lt;span class=&quot;c&quot;&gt;# 链接 setup.elf 文件和 header.o 文件生成 setup.bin 文件&lt;/span&gt;
  OBJCOPY &lt;span class=&quot;nb&quot;&gt;arch&lt;/span&gt;/x86/boot/setup.bin
  BUILD   &lt;span class=&quot;nb&quot;&gt;arch&lt;/span&gt;/x86/boot/bzImage &lt;span class=&quot;c&quot;&gt;# 最后将 vmlinux.bin 和 setup.bin 文件链接到一起生成 bzImage 内核镜像文件&lt;/span&gt;
Setup is 15612 bytes &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;padded to 15872 bytes&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
System is 6254 kB
CRC 88b350d1 &lt;span class=&quot;c&quot;&gt;#生成 CRC 校验码，添加到bzImage 内核镜像的末尾&lt;/span&gt;
Kernel: &lt;span class=&quot;nb&quot;&gt;arch&lt;/span&gt;/x86/boot/bzImage is ready  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;c&quot;&gt;#1)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;整个从 vmlinux 内核镜像文件生成一个可被加载启动的内核镜像文件的过程可以用下面这张图来描述：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://picturebed.obs.cn-east-2.myhuaweicloud.com/blogPictures/14984462874879.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有关 x86 架构 Linux Kernel 启动相关的具体细节可以查看内核源码中的文档：&lt;a href=&quot;https://www.kernel.org/doc/Documentation/x86/boot.txt&quot;&gt;THE LINUX/x86 BOOT PROTOCOL&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;linux-kernel-加载过程&quot;&gt;Linux Kernel 加载过程&lt;/h2&gt;

&lt;p&gt;Bootloader 将内核镜像加载到物理内存之后，内存的布局如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://picturebed.obs.cn-east-2.myhuaweicloud.com/blogPictures/14984488084415.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;整个Linux Kernel 的加载过程就是对 Linux Kernel 镜像分阶段加载，然后在实模式中进行一些基本硬件的设置，建立页表等操作之后，跳转到保护模式下的内核入口开始执行。&lt;/p&gt;

&lt;h2 id=&quot;实模式下内核加载过程&quot;&gt;实模式下内核加载过程&lt;/h2&gt;
&lt;p&gt;Bootloader 在找到内核镜像之后，第一步做的工作就是将内核镜像文件中的起始第一部分 &lt;strong&gt;boot/setup.bin&lt;/strong&gt; 加载到 &lt;strong&gt;0x7c00&lt;/strong&gt; 地址之上的物理内存中，然后跳转到 setup.bin 文件中的入口地址开始执行，注意这部分的代码是在&lt;strong&gt;实模式&lt;/strong&gt;下运行的。&lt;/p&gt;

&lt;p&gt;如在 &lt;strong&gt;Linux Kernel 镜像生成过程&lt;/strong&gt; 小节中可启动的内核镜像图所示，boot/setup.bin 文件是由 &lt;strong&gt;boot sector&lt;/strong&gt;（注意这个 boot sector 和 MBR 扇区是不一样的，是内核中遗留下来的一块地方，现在基本不怎么使用这块地方了，可能在其他体系架构的内核镜像中会使用这一部分来存储一些参数） 和 &lt;strong&gt;setup 代码&lt;/strong&gt; 组成，其中 boot sector 占用了 512 字节的空间。&lt;/p&gt;

&lt;p&gt;实模式设置（setup）阶段主要完成一些&lt;strong&gt;体系结构相关的硬件初始化工作&lt;/strong&gt;，涉及的文件有 &lt;em&gt;arch/x86/boot/header.S&lt;/em&gt;、链接脚本&lt;em&gt;setup.ld&lt;/em&gt;、&lt;em&gt;arch/x86/boot/main.c&lt;/em&gt;。header.S 第一部分定义了 .bstext、.bsdata、.header 这 3 个节，共同构成了vmlinuz 的第一个512字节(即引导扇区的内容)。常量 BOOTSEG 和SYSSEG 定义了引导扇区和内核的载入的地址。&lt;/p&gt;

&lt;p&gt;header.S 文件中的部分代码如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BOOTSEG     = 0x07C0        /* original address of boot-sector */
SYSSEG      = 0x1000        /* historical load address &amp;gt;&amp;gt; 4 */

......

    .code16
    .section &quot;.bstext&quot;, &quot;ax&quot; /* .bstext 小节 */

    .global bootsect_start
bootsect_start:
#ifdef CONFIG_EFI_STUB
    # &quot;MZ&quot;, MS-DOS header
    .byte 0x4d
    .byte 0x5a
#endif

    # Normalize the start address
    ljmp    $BOOTSEG, $start2

start2:
    movw    %cs, %ax
    movw    %ax, %ds
    movw    %ax, %es
    movw    %ax, %ss
    xorw    %sp, %sp
    sti
    cld

    movw    $bugger_off_msg, %si
    
......

.section &quot;.bsdata&quot;, &quot;a&quot; /* .bsdata 小节 */
bugger_off_msg:
    .ascii  &quot;Use a boot loader.\r\n&quot;
    .ascii  &quot;\n&quot;
    .ascii  &quot;Remove disk and press any key to reboot...\r\n&quot;
    .byte   0
    
......

# Kernel attributes; used by setup.  This is part 1 of the
    # header, from the old boot sector.

    .section &quot;.header&quot;, &quot;a&quot; /* .header 小节 */
    .globl  sentinel
sentinel:   .byte 0xff, 0xff        /* Used to detect broken loaders */

    .globl  hdr
hdr:
setup_sects:    .byte 0         /* Filled in by build.c */
root_flags: .word ROOT_RDONLY
syssize:    .long 0         /* Filled in by build.c */
ram_size:   .word 0         /* Obsolete */
vid_mode:   .word SVGA_MODE
root_dev:   .word 0         /* Filled in by build.c */
boot_flag:  .word 0xAA55

/*---------------------512 字节偏移处-----------------------------*/

/* _start 位置是内核装载时实模式执行代码的入口地址
    这一点我们可以从 setup.ld 脚本文件中的 ENTRY(_start) 
    得知
 */
/* 从 _start 开始真正的进入实模式开始执行 setup 代码 */
# offset 512, entry point

    .globl  _start
_start:
        # Explicitly enter this as bytes, or the assembler
        # tries to generate a 3-byte jump here, which causes
        # everything else to push off to the wrong offset.
        .byte   0xeb        # short (2-byte) jump
        .byte   start_of_setup-1f

......

# Zero the bss
    movw    $__bss_start, %di
    movw    $_end+3, %cx
    xorl    %eax, %eax
    subw    %di, %cx
    shrw    $2, %cx
    rep; stosl

# Jump to C code (should not return)
    calll   main

# Setup corrupt somehow...
setup_bad:
    movl    $setup_corrupt, %eax
    calll   puts
    # Fall through...

    .globl  die
    .type   die, @function
die:
    hlt
    jmp die

    .size   die, .-die

    .section &quot;.initdata&quot;, &quot;a&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;setup.ld 链接脚本&lt;/strong&gt;的工作就是将 header.S 中的各个小节按照 ELF 可执行文件格式链接在一起，最终生成 &lt;strong&gt;boot/setup.bin&lt;/strong&gt;  文件，setup.ld 文件中的部分内容如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/*
 * setup.ld
 *
 * Linker script for the i386 setup code
 */
OUTPUT_FORMAT(&quot;elf32-i386&quot;, &quot;elf32-i386&quot;, &quot;elf32-i386&quot;)
OUTPUT_ARCH(i386)
ENTRY(_start)

SECTIONS
{
    . = 0;
    .bstext     : { *(.bstext) }
    .bsdata     : { *(.bsdata) }

    . = 495;
    .header     : { *(.header) }
    .entrytext  : { *(.entrytext) }
    .inittext   : { *(.inittext) }
    .initdata   : { *(.initdata) }
    __end_init = .;

    .text       : { *(.text) }
    .text32     : { *(.text32) }

    . = ALIGN(16);
    .rodata     : { *(.rodata*) }
    
    ......

    . = ALIGN(16);
    .data       : { *(.data*) }

    .signature  : {
        setup_sig = .;
        LONG(0x5a5aaa55)
    }
    
    ....
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由 setup.ld 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;ENTRY(_start)&lt;/code&gt; 可知，&lt;strong&gt;header.S&lt;/strong&gt; 文件中 &lt;code class=&quot;highlighter-rouge&quot;&gt;_start&lt;/code&gt; 汇编程序是 bzImage 内核映像开始执行的入口点，即引导扇区之后的开始处（偏移512字节处），它会准备大量的&lt;strong&gt;bootloader&lt;/strong&gt; 参数，最后的 &lt;code class=&quot;highlighter-rouge&quot;&gt;call main&lt;/code&gt; 跳转到 &lt;code class=&quot;highlighter-rouge&quot;&gt;arch/x86/boot/main.c:main()&lt;/code&gt; 函数处执行，这就是众所周知的 main 函数，它们都工作在&lt;strong&gt;实模式&lt;/strong&gt;下。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;arch/x86/boot/main.c:main()&lt;/strong&gt; 函数主要完成的工作：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;copy_boot_params&lt;/code&gt; 函数把位于第一个扇区(boot/setup.bin 中的 boot sector)的参数复制到 &lt;strong&gt;boot_params&lt;/strong&gt; 变量中，boot_params 变量位于 &lt;strong&gt;boot/setup.bin&lt;/strong&gt; 的数据段。&lt;/li&gt;
  &lt;li&gt;初始化早期启动状态下的控制台（console）。&lt;/li&gt;
  &lt;li&gt;初始化堆空间。&lt;/li&gt;
  &lt;li&gt;检测 CPU 相关信息。&lt;/li&gt;
  &lt;li&gt;通过向 BIOS 查询的方式，收集硬件相关信息，并将结果存放在第 0 号物理页中。&lt;/li&gt;
  &lt;li&gt;调用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;arch/x86/boot/pm.c:go_to_protected_mode(void) ---&amp;gt; arch/x86/boot/pmjump.S:protected_mode_jump()&lt;/code&gt; 函数，从 bzImage 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;boot/setup.bin&lt;/code&gt; &lt;strong&gt;实模式部分&lt;/strong&gt;的代码跳转到了 &lt;code class=&quot;highlighter-rouge&quot;&gt;boot/vmlinux.bin&lt;/code&gt; &lt;strong&gt;保护模式&lt;/strong&gt;的代码。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;保护模式下内核加载过程&quot;&gt;保护模式下内核加载过程&lt;/h2&gt;
&lt;p&gt;执行完 &lt;strong&gt;boot/setup.bin&lt;/strong&gt; 部分的代码之后，Bootloader 就接着把内核镜像 bzImage 中的第二部分 &lt;strong&gt;boot/vmlinux.bin&lt;/strong&gt; 加载到物理内存中起始地址为 &lt;strong&gt;0x100000&lt;/strong&gt; 的位置，boot/vmlinux.bin 代码在&lt;strong&gt;保护模式&lt;/strong&gt;下的入口是 &lt;code class=&quot;highlighter-rouge&quot;&gt;arch/x86/boot/compressed/head_32.S::startup_32&lt;/code&gt; 汇编代码，这段汇编代码中主要完成两个工作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;将 boot/vmlinux.bin 文件中解压内核的代码拷贝到物理内存中 boot/vmlinux.bin 的后面。&lt;/li&gt;
  &lt;li&gt;初始化 stack 和 heap 空间。&lt;/li&gt;
  &lt;li&gt;解压缩内核，解压缩后的内核就是我们从源码编译得到的 vmlinux ELF 可执行文件。&lt;/li&gt;
  &lt;li&gt;如果有选项指定，可能还需要对解压后的内核地址进行一个重定位（Relocate）。&lt;/li&gt;
  &lt;li&gt;最后，跳转到解压缩后的内核文件 vmlinux 中的入口函数开始启动内核。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;解压缩后的内核文件 vmlinux 的入口函数是 &lt;code class=&quot;highlighter-rouge&quot;&gt;arch/x86/kernel/head_32.S::startup_32&lt;/code&gt; 中的startup_32（32位内核的入口函数），在这个函数中会拷贝 &lt;strong&gt;boot_params&lt;/strong&gt; 结构体变量以及&lt;strong&gt;boot_command_line&lt;/strong&gt;，初始化页表，开启分页机制。startup_32() 汇编代码会接着调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;init/main.c:start_kernel()&lt;/code&gt; 函数，这是Linux 内核的启动函数。&lt;code class=&quot;highlighter-rouge&quot;&gt;init/main.c&lt;/code&gt; 文件是整个 Linux 内核的中央联结点。每种体系结构都会执行一些底层设置函数，然后执行名为&lt;code class=&quot;highlighter-rouge&quot;&gt;start_kernel&lt;/code&gt; 的函数（在 init/main.c 中可以找到这个函数）。可以认为 main.c 是内核的“粘合剂（glue）”，之前执行的代码都是&lt;strong&gt;各种体系结构相关&lt;/strong&gt;的代码，一旦到达&lt;strong&gt;start_kernel()&lt;/strong&gt;，就与体系结构无关了。&lt;/p&gt;

&lt;p&gt;至此，Linux Kernel 的加载过程就分析完毕了，整个过程可以用下面这张图来总结一下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://picturebed.obs.cn-east-2.myhuaweicloud.com/blogPictures/14984654332695.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;参考文章&quot;&gt;参考文章&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://linux-development-for-fresher.blogspot.com/2012/07/linux-boot-process-in-nutshell.html&quot;&gt;Linux Boot Process in a nutshell&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.kernel.org/doc/Documentation/efi-stub.txt&quot;&gt;The EFI Boot Stub&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.kernel.org/doc/Documentation/efi-stub.txt&quot;&gt;Archlinux-EFISTUB&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.wowotech.net/armv8a_arch/UEFI.html&quot;&gt;ARM64的启动过程之（五）：UEFI&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wiki.archlinux.org/index.php/Unified_Extensible_Firmware_Interface&quot;&gt;Unified Extensible Firmware Interface - ArchWiki&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.woodelf.org/2014/05/28/uefi-boot-how-it-works.html&quot;&gt;UEFI 启动：实际工作原理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.rodsbooks.com/efi-bootloaders/principles.html&quot;&gt;Managing EFI Boot Loaders for Linux:BasicPrinciples&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/duguteng/article/details/7552774&quot;&gt;x86中断向量表&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://wiki.osdev.org/Boot_Sequence&quot;&gt;Boot Sequence&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.linuxidc.com/Linux/2014-10/108033.htm&quot;&gt;Linux内核启动过程分析&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Tue, 27 Jun 2017 00:35:33 +0800</pubDate>
        <link>http://localhost:4000/%E5%86%85%E6%A0%B8/2017/06/27/Linux-%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BD%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E5%86%85%E6%A0%B8/2017/06/27/Linux-%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BD%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90.html</guid>
        
        <category>内核</category>
        
        <category>操作系统</category>
        
        
        <category>内核</category>
        
      </item>
    
      <item>
        <title>ramfs, tmpfs, rootfs, initramfs的区别</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://picturebed.obs.cn-east-2.myhuaweicloud.com/blogPictures/14973695337147.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;什么是文件系统&quot;&gt;什么是文件系统？&lt;/h1&gt;

&lt;p&gt;如果你接触过Linux系统中的文件系统，相信你对下面这些名词肯定不会陌生，例如：ext2, ext3, ext4, FAT, FAT32, tmpfs, rootfs, NTFS, YAFFS, sysfs, procfs 等等。俺滴神啊，怎么会有这么多不同类型的文件系统啊，那么文件系统到底是个什么东西呢？&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;下面是引用自Wikipedia上关于&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F&quot;&gt;文件系统&lt;/a&gt;的介绍：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在计算机系统中，文件系统（file system）是一种存储和组织数据的一种方法，它使得对数据发访问和查找变得更加容易。&lt;/p&gt;

  &lt;p&gt;文件系统使用&lt;strong&gt;文件&lt;/strong&gt;和&lt;strong&gt;树形目录&lt;/strong&gt;的抽象逻辑概念代替了硬盘和光盘等物理存储设备所用的数据块的概念，用户使用文件系统来保存数据而不必关系数据实际保存在物理存储设备的地址为多少的数据块中，用户只需要记住这个文件的所属目录和文件名即可。在写入数据之前，用户也不必关心硬盘上哪个数据块没有被使用，所有的物理存储设备的存储空间的分配和释放功能都是由文件系统自动完成，用户只需要记住数据被写入到了哪个文件中。&lt;/p&gt;

  &lt;p&gt;文件系统可以用来在不同的物理存储介质上存储和组织数据，通常最常见的物理存储设备是硬盘，光盘以及Flash，磁带等等。但是，在某些情况下文件系统也可以使用内存（random-access memory，RAM）作为文件的存储介质，例如tmpfs，当文件存储在这种存储介质上时，一旦计算机掉电之后，该介质上面的所有文件就都消失了。甚至有的文件系统可能根本没有对应的文件，例如如proc文件系统。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;什么是-ramfs&quot;&gt;什么是 ramfs？&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Ramfs&lt;/strong&gt; 是一个空间大小动态可变的基于 RAM 的文件系统，它是Linux 用来实现磁盘缓存（page cache and dentry cache）的文件系统。&lt;/p&gt;

&lt;p&gt;ramfs 是一个仅存在与内存中文件系统，它没有后备存储（例如磁盘），也就是说 ramfs 文件系统所管理的文件都是存放在内存中，而不存放在磁盘中，如果计算机掉电关闭，那么 ramfs 文件系统中所有文件也就都没有了。&lt;/p&gt;

&lt;p&gt;当普通磁盘中的文件被操作系统加载到内存中时，内核会分配 page 来存储文件中的内容，然后进程通过读写内存中文件对应的 page 实现对文件的读写修改操作，当完成了所有的读写操作之后，文件对应的 page 就会被标记为&lt;strong&gt;脏页&lt;/strong&gt;，然后在合适的时机被操作系统写回到原来的磁盘中对应的文件中，内存中原来存放这些文件的 page 就会被标记为干净，最后被系统回收重新使用。而 ramfs 文件系统中的文件当同样被加载到内存中 page 进行读写操作之后，它对应的 page 并不会被标记为&lt;strong&gt;脏页&lt;/strong&gt;，因为 ramfs 中文件没有下级的后备存储器（例如，磁盘），也就没有了写回后备存储器的操作，所以为它分配的这些 page 也就无法回收了。&lt;/p&gt;

&lt;h1 id=&quot;什么是-tmpfs&quot;&gt;什么是 tmpfs？&lt;/h1&gt;
&lt;p&gt;ramfs 中有一个非常大的&lt;strong&gt;缺点&lt;/strong&gt;就是你可以持续不断地向 ramfs 文件系统中的文件持续不断地写入数据直到填满整个物理内存空间为止。出现这个问题的原因就是前面介绍的 ramfs 文件系统不存在向普通磁盘那样的将内存中的文件内容写回到文件的操作，也就导致了它所占据的那部分内存空间是无法被释放的，正是因为这个原因，通常只有 &lt;strong&gt;root&lt;/strong&gt; 用户才有读写 ramfs 文件系统中文件的权限。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;tmpfs&lt;/strong&gt; 文件系统是从 &lt;strong&gt;ramfs&lt;/strong&gt; 衍生而来的一个文件系统，但是它相对于 ramfs 多了&lt;strong&gt;空间容量大小限制&lt;/strong&gt;，并且还可以将文件系统中一些&lt;strong&gt;不必要的的文件内容写到交换空间&lt;/strong&gt;中（swap space）。并且 tmpfs 文件系统的大小还可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;mount -o remount ...&lt;/code&gt; 命令来重新调整。&lt;/p&gt;

&lt;p&gt;有关 tmpfs 更加详细的内容可以查看内核源码中的文档：&lt;em&gt;Documentation/filesystems/tmpfs.txt&lt;/em&gt;。&lt;/p&gt;

&lt;h2 id=&quot;什么是-rootfs&quot;&gt;什么是 rootfs？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;rootfs&lt;/strong&gt;（也叫根文件系统） 它本质上就是一个 Linux 系统中基本的文件目录组织结构，也就是 Linux 系统中 &lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt; 根目录下的结构，例如，&lt;code class=&quot;highlighter-rouge&quot;&gt;/boot&lt;/code&gt; 目录下存放的是启动内核相关的文件，&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc&lt;/code&gt; 目录中存放的则是一些系统配置文件，&lt;code class=&quot;highlighter-rouge&quot;&gt;/dev&lt;/code&gt; 目录下存放的则是系统的设备文件，&lt;code class=&quot;highlighter-rouge&quot;&gt;/bin&lt;/code&gt; 目录下存放的则是一些可执行的二进制文件等等，在我的 Ubuntu 机器上的 &lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt; 根目录的结构如下所示：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
├── bin
├── boot
├── cdrom
├── data
├── dev
├── etc
├── home
├── initrd.img -&amp;gt; boot/initrd.img-3.13.0-107-generic
├── lib
├── lib32
├── lib64
├── libx32
├── lost+found
├── media
├── mnt
├── opt
├── proc
├── root
├── run
├── sbin
├── srv
├── sys
├── tmp
├── usr
├── var
└── vmlinuz -&amp;gt; boot/vmlinuz-4.2.0-27-generic

24 directories, 5 files
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通常 rootfs 文件系统应该非常简洁，它只包含了它所必须用的文件，并且尽量避免少去修改 rootfs，以免破坏 rootfs，导致整个 Linux 系统无法启动。&lt;/p&gt;

&lt;p&gt;Linux 系统的启动过程与 &lt;code class=&quot;highlighter-rouge&quot;&gt;rootfs&lt;/code&gt; 也是密切相关，rootfs 可能会存在于存储在 RAM 存储设备中，也可能会存在硬盘设备中，这部分的我会在 Linux 系统的启动过程中作介绍。&lt;/p&gt;

&lt;h2 id=&quot;什么是-initramfs&quot;&gt;什么是 initramfs？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;initramfs&lt;/strong&gt; 是一种以 &lt;code class=&quot;highlighter-rouge&quot;&gt;cpio&lt;/code&gt; 格式压缩后的 rootfs 文件系统，它通常和 Linux 内核文件一起被打包成 boot.img 作为启动镜像，BootLoader 加载 boot.img，并启动内核之后，内核接着就对 &lt;code class=&quot;highlighter-rouge&quot;&gt;cpio&lt;/code&gt; 格式的 initramfs 进行解压，并将解压后得到的 &lt;code class=&quot;highlighter-rouge&quot;&gt;rootfs&lt;/code&gt; 加载进内存，最后内核会检查 rootfs 中是否存在 &lt;strong&gt;init&lt;/strong&gt; 可执行文件（该 init 文件本质上是一个执行的 shell 脚本），如果存在，就开始执行 &lt;strong&gt;init&lt;/strong&gt; 程序并创建 Linux 系统用户空间 PID 为 1 的进程，然后将磁盘中存放根目录内容的分区真正地挂载到 &lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt; 根目录上，最后通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;exec chroot . /sbin/init&lt;/code&gt; 命令来将 rootfs 中的根目录切换到挂载了实际磁盘分区文件系统中，并执行 &lt;strong&gt;/sbin/init&lt;/strong&gt; 程序来启动系统中的其他进程和服务。&lt;/p&gt;

&lt;p&gt;有关更加详细的 Linux Kernel + initramfs 的启动过程可以阅读下面这篇文章：&lt;a href=&quot;http://xstarcd.github.io/wiki/Linux/ShengRuLiJie_linux_2.6_initramfs.html&quot;&gt;深入理解Linux 2.6 的initramfs 机制&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;参考文章&quot;&gt;参考文章&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F&quot;&gt;wiki-文件系统&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.linfo.org/root_filesystem.html&quot;&gt;Root Filesystem Definition&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt&quot;&gt;Kernel-doc:ramfs, rootfs and initramfs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.kernel.org/doc/Documentation/filesystems/tmpfs.txt&quot;&gt;Kernel-doc: tmpfs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://xstarcd.github.io/wiki/Linux/ShengRuLiJie_linux_2.6_initramfs.html&quot;&gt;深入理解Linux 2.6 的initramfs 机制&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/goodboychina/article/details/27306985&quot;&gt;initramfs完全解读&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/fjb2080/article/details/5344525&quot;&gt;跟我一步一步制作一个基本的linux启动盘&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Wed, 14 Jun 2017 08:00:51 +0800</pubDate>
        <link>http://localhost:4000/%E5%86%85%E6%A0%B8/2017/06/14/ramfs-rootfs-initramfs%E7%9A%84%E5%8C%BA%E5%88%AB.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E5%86%85%E6%A0%B8/2017/06/14/ramfs-rootfs-initramfs%E7%9A%84%E5%8C%BA%E5%88%AB.html</guid>
        
        <category>ramfs</category>
        
        <category>tmpfs</category>
        
        <category>rootfs</category>
        
        <category>initramfs</category>
        
        <category>文件系统</category>
        
        <category>Linux</category>
        
        
        <category>内核</category>
        
      </item>
    
      <item>
        <title>Android HAL 层原理分析</title>
        <description>&lt;h2 id=&quot;android-hal-简介&quot;&gt;Android HAL 简介&lt;/h2&gt;
&lt;p&gt;Android 系统硬件抽象层（Hardware Abstract Layer）运行在用户空间中，它向下屏蔽了硬件驱动的实现细节，向上提供了硬件访问的服务。通过 HAL 层，Android 系统分为两层来支持硬件设备，其中一层实现在用户空间，另外一层实现在内核空间中，它在 Android 系统框架中的位置如下图所示。传统的 Linux 系统则把对硬件的支持和管理全部放在内核空间中,即把对硬件的全部支持都放在硬件驱动模块当中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://picturebed.obs.cn-east-2.myhuaweicloud.com/blogPictures/20170324149036043728849.png&quot; alt=&quot;20170324149036043728849.png&quot; /&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;为什么要添加一个-hal-层&quot;&gt;为什么要添加一个 HAL 层？&lt;/h2&gt;
&lt;p&gt;Android 在用户空间中新建一个的 HAL 层来支持硬件设备的主要原因还是因为 Android 使用的开源协议是 Apache License，这个协议比较宽松，它允许开发者获取并修改了源码之后，不用把源码公开出来。而 Linux 使用的开源协议 GPL，它的要求限制就比较多，它要求开发者添加或修改了源码之后，必须把添加或修改后的代码公开出来，所以我们在 Linux 内核中的所使用的设备驱动程序都是源码公开的，任何人都可以获取并修改它。&lt;/p&gt;

&lt;p&gt;因此，如果 Android 系统像其他 Linux 系统一样，把对硬件的支持完全实现在 Linux 内核的驱动模块中，那么硬件厂商就必须将这些硬件驱动源码公开，这样就可能损害到移动厂商的利益，因为这相当于暴露了硬件的实现细节和参数。&lt;/p&gt;

&lt;p&gt;所以，Android 就在用户空间搞了一个 HAL 层，将硬件的一些重要的操作都放在这一层中完成，这些操作都封装在厂商所提供的一个动态链接库中，从而达到了避免源码公开的目的，而底层 Linux 内核空间中的设备驱动模块，现在则只提供一些最基本的硬件设备寄存器操作的功能。&lt;/p&gt;

&lt;h2 id=&quot;hal-模块是如何实现的&quot;&gt;HAL 模块是如何实现的？&lt;/h2&gt;
&lt;p&gt;由于最近一直在做一个 Android-x86 系统相关的项目，其中就有一部分是跟音频 HAL 模块紧密相关，所以我就重新对 HAL 的相关知识进行了一个学习和整理，所以本文中将以音频系统对应的 audio HAL 模块（ 它最终是以 &lt;code class=&quot;highlighter-rouge&quot;&gt;audio.primary.x86.so&lt;/code&gt; 的动态链接库形式存在 ）为例来介绍一个 HAL 模块的定义及实现过程。&lt;/p&gt;

&lt;h3 id=&quot;hal-层的三个重要结构体&quot;&gt;HAL 层的三个重要结构体&lt;/h3&gt;
&lt;p&gt;Android 系统的 HAL 层其实并不复杂，只要你能理解清楚下面这 3 个结构体的含义：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;hw_module_t&lt;/strong&gt;：用来描述硬件模块&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;hw_device_t&lt;/strong&gt;：用来描述硬件设备&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;hw_module_methods_t&lt;/strong&gt;：用来打开硬件模块中包含硬件设备，获得指向硬件设备结构体的指针&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Android 系统中 HAL 层是以&lt;strong&gt;模块&lt;/strong&gt;的方式来管理各个硬件访问的接口，每一个硬件模块都对应一个动态链接库文件，而这些动态链接库文件需要符号一定的规范，而上述的这 3 种结构体就是用来建立这种规范。并且一个&lt;strong&gt;硬件模块&lt;/strong&gt;可以管理多个&lt;strong&gt;硬件设备&lt;/strong&gt;，例如 audio HAL 硬件模块中就管理了扬声器、麦克风等多个硬件设备。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：这里一定区分 hw_module_t 和 hw_device_t 它们所表示的含义&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;hw_module_t&quot;&gt;hw_module_t&lt;/h4&gt;
&lt;p&gt;结构体 hw_module_t 定义在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/hardware/libhardware/include/hardware/hardware.h&lt;/code&gt; 文件中，其定义如下所示：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * Every hardware module must have a data structure named HAL_MODULE_INFO_SYM
 * and the fields of this data structure must begin with hw_module_t
 * followed by module specific information.
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hw_module_t&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/** tag must be initialized to HARDWARE_MODULE_TAG */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/**
     * The API version of the implemented module. The module owner is
     * responsible for updating the version when a module interface has
     * changed.
     *
     * The derived modules such as gralloc and audio own and manage this field.
     * The module user must interpret the version field to decide whether or
     * not to inter-operate with the supplied module implementation.
     * For example, SurfaceFlinger is responsible for making sure that
     * it knows how to manage different versions of the gralloc-module API,
     * and AudioFlinger must know how to do the same for audio-module API.
     *
     * The module API version should include a major and a minor component.
     * For example, version 1.0 could be represented as 0x0100. This format
     * implies that versions 0x0100-0x01ff are all API-compatible.
     *
     * In the future, libhardware will expose a hw_get_module_version()
     * (or equivalent) function that will take minimum/maximum supported
     * versions as arguments and would be able to reject modules with
     * versions outside of the supplied range.
     */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint16_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module_api_version&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define version_major module_api_version
&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/**
     * version_major/version_minor defines are supplied here for temporary
     * source code compatibility. They will be removed in the next version.
     * ALL clients must convert to the new version format.
     */&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/**
     * The API version of the HAL module interface. This is meant to
     * version the hw_module_t, hw_module_methods_t, and hw_device_t
     * structures and definitions.
     *
     * The HAL interface owns this field. Module users/implementations
     * must NOT rely on this value for version information.
     *
     * Presently, 0 is the only valid value.
     */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint16_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hal_api_version&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define version_minor hal_api_version
&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/** Identifier of module */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/** Name of this module */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/** Author/owner/implementor of the module */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;author&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/** Modules methods */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hw_module_methods_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;methods&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/** module's dso */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dso&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;#ifdef __LP64__
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reserved&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#else
&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/** padding to 128 bytes, reserved for future use */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reserved&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hw_module_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们先看下结构体 hw_module_t 定义最前面的一段注释说明，它的意思是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;每个硬件模块中都要定义一个名字叫做 HAL_MODULE_INFO_SYM 结构体变量，而这结构体变量中的第一个成员必须是  hw_module_t 类型。也就是说，每个硬件模块都要自己实现一个结构体，但是这个结构体的第一个成员必须是 hw_module_t 结构体类型。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;其实这里蕴含着一种面向对象中继承的思想，hw_module_t 就是一个基类，描述所有硬件模块都应该具有的一些属性，然后具体到某个特定的硬件模块实现时，都需要继承自 hw_module_t 结构体。也就是说 hw_module_t 是所有特定硬件模块的父类。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有关结构体 hw_module_t 中各个成员的具体含义，这里就不一一进行说明了，相信大家从它们的注释说明中就能了解到每一个成员所表示的含义，这里就挑一些重要的结构体成员来进一步说明。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;id：这个成员用一个字符串来表示硬件模块的，用来区别于其他硬件模块。&lt;/li&gt;
  &lt;li&gt;methods：这个成员是一个 hw_module_methods_t 指针，它表示硬件模块所包含的方法集（其实里面就一个 open 函数指针，用来打开 hw_device_t 硬件设备，获得指向对应的硬件设备的结构体对象的指针）。&lt;/li&gt;
  &lt;li&gt;dso：我们前面提到，HAL 层中的&lt;strong&gt;硬件模块&lt;/strong&gt;是用动态链接库表示的，所以 dso 指针就是系统使用 dlopen() 函数打开共享动态共享链接库之后获得的句柄。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;hw_device_t&quot;&gt;hw_device_t&lt;/h4&gt;
&lt;p&gt;结构体 hw_device_t 定义在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/hardware/libhardware/include/hardware/hardware.h&lt;/code&gt; 文件中，其定义如下所示：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * Every device data structure must begin with hw_device_t
 * followed by module specific public methods and attributes.
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hw_device_t&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/** tag must be initialized to HARDWARE_DEVICE_TAG */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/**
     * Version of the module-specific device API. This value is used by
     * the derived-module user to manage different device implementations.
     *
     * The module user is responsible for checking the module_api_version
     * and device version fields to ensure that the user is capable of
     * communicating with the specific module implementation.
     *
     * One module can support multiple devices with different versions. This
     * can be useful when a device interface changes in an incompatible way
     * but it is still necessary to support older implementations at the same
     * time. One such example is the Camera 2.0 API.
     *
     * This field is interpreted by the module user and is ignored by the
     * HAL interface itself.
     */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/** reference to the module this device belongs to */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hw_module_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/** padding reserved for future use */&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#ifdef __LP64__
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reserved&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#else
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reserved&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/** Close this device */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hw_device_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hw_device_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;和 hw_module_t 类似，hw_device_t 也可以看做是一个基类，它描述了所有硬件设备都应该具有的属性，然后具体到某个特定的硬件设备（例如，音频播放时需要的扬声器设备）实现时，都需要继承自 audio_device 结构体。所以，每个 HAL 层中硬件设备对应的结构体中的第一个成员必须是 hw_device_t。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下面还是简单提一下结构体 hw_device_t 比较关键的几个成员：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;module：这个成员是一个 hw_module_t 指针，表示该结构体 hw_device_t 表示的&lt;strong&gt;硬件设备&lt;/strong&gt;是由哪个 hw_module_t 表示的&lt;strong&gt;硬件模块&lt;/strong&gt;进行管理的。（在这里所以一定要区分清楚==&lt;strong&gt;硬件设备&lt;/strong&gt;==和==&lt;strong&gt;硬件模块&lt;/strong&gt;==的区别！）&lt;/li&gt;
  &lt;li&gt;close：这是一个函数指针，表示如何关闭打开的硬件设备，通常==打开硬件设备的操作==在 hw_module_t 中包含的 hw_module_methods_t 函数列表中的 &lt;strong&gt;open()&lt;/strong&gt; 函数中打开的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;hw_module_methods_t&quot;&gt;hw_module_methods_t&lt;/h4&gt;
&lt;p&gt;结构体 hw_module_methods_t 定义在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/hardware/libhardware/include/hardware/hardware.h&lt;/code&gt; 文件中，其定义如下所示：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hw_module_methods_t&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/** Open a specific device */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hw_module_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hw_device_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hw_module_methods_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结构体 hw_module_methods_t 就比较简单了，它里面就只有一个 &lt;strong&gt;open&lt;/strong&gt; 函数指针，用来打开 module 硬件模块==所管理==的硬件设备id值为 id 的硬件设备，最后将打开的==硬件设备（用 hw_device_t 结构体来描述）==通过 device 返回。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：这个 open 函数明确指出第三个参数的类型为 struct hw_device_t**，这主要是为了统一不同硬件设备向上层提供的硬件接口，然后在具体使用到某中硬件设备时，再转换成特定硬件设备的结构体类型。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;audio-hal-模块的实现&quot;&gt;Audio HAL 模块的实现&lt;/h2&gt;

&lt;h3 id=&quot;step-1定义-struct-audio_module-模块&quot;&gt;Step 1：定义 struct audio_module 模块&lt;/h3&gt;
&lt;p&gt;我们前面在结构体 hw_module_t 介绍时，有提到具体的&lt;strong&gt;硬件模块&lt;/strong&gt;要定义一个新的结构体并且这个结构体的==第一个成员必须是 hw_module_t 类型==，所以根据这个规则，audio_module 的定义如下所示：
代码路径：&lt;code class=&quot;highlighter-rouge&quot;&gt;/hardware/libhardware/include/hardware/audio.h&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;audio_module&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hw_module_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;step-2定义-struct-audio_module-类型的-hal_module_info_sym-变量&quot;&gt;step 2：定义 struct audio_module 类型的 HAL_MODULE_INFO_SYM 变量&lt;/h3&gt;
&lt;p&gt;HAL_MODULE_INFO_SYM 其实是一个宏，它定义如下所示：
代码路径：&lt;code class=&quot;highlighter-rouge&quot;&gt;/hardware/libhardware/include/hardware/hardware.h&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * Name of the hal_module_info
 */&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define HAL_MODULE_INFO_SYM         HMI
&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/**
 * Name of the hal_module_info as a string
 */&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define HAL_MODULE_INFO_SYM_AS_STR  &quot;HMI&quot;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而 struct audio_module 类型名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;HAL_MODULE_INFO_SYM&lt;/code&gt; 变量的定义如下所示：
代码路径：&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;aosp&amp;gt;/generic/goldfish/audio/audio_hw.c&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;audio_module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HAL_MODULE_INFO_SYM&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HARDWARE_MODULE_TAG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module_api_version&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AUDIO_MODULE_API_VERSION_0_1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hal_api_version&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HARDWARE_HAL_API_VERSION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AUDIO_HARDWARE_MODULE_ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Generic audio HW HAL&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;author&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;The Android Open Source Project&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;methods&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hal_module_methods&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;```&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;但是我们为什么要在每个硬件模块中都定义一个变量名为&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HAL_MODULE_INFO_SYM&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;的变量呢？&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;原因是&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;为了统一标准的接口&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;。这个硬件模块类型的变量主要是在&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HAL&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;动态链接库加载时用到，它使得上层的&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Framework&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;层打开所有的&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HAL&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;动态链接库时都能找到名为&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HAL&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_MODULE&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_INFO&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_SYM&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;（也就是&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hmi&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;）的硬件模块类型变量，然后通过这个变量再来打开它所管理的硬件设备，从而与之进行交互。这么做的好处就是&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Framework&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;层中只需要用相同的&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;API&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，就能处理各个厂商所提供的不同的&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HAL&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;动态链接库。&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;### step 3：定义 struct audio\_hw\_device 硬件设备结构体
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;每个硬件设备都需要通过一个结构体来表示，并且这个结构体的第一个成员必须是&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hw&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_device&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_t&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;类型。而有关的对底层硬件设备的有关操作的函数指针接口，也是在这个结构体中定义。&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;audio&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_hw&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_device&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;硬件设备结构体的定义如下所示：&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;代码路径：`&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hardware&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libhardware&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hardware&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;audio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;```&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;audio_hw_device&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/**
     * Common methods of the audio device.  This *must* be the first member of audio_hw_device
     * as users of this structure will cast a hw_device_t to audio_hw_device pointer in contexts
     * where it's known the hw_device_t references an audio_hw_device.
     */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hw_device_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;......&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/* Returns audio input buffer size according to parameters passed or
     * 0 if one of the parameters is not supported.
     * See also get_buffer_size which is for a particular stream.
     */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_input_buffer_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;audio_hw_device&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;audio_config&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/** This method creates and opens the audio hardware output stream.
     * The &quot;address&quot; parameter qualifies the &quot;devices&quot; audio device type if needed.
     * The format format depends on the device type:
     * - Bluetooth devices use the MAC address of the device in the form &quot;00:11:22:AA:BB:CC&quot;
     * - USB devices use the ALSA card and device numbers in the form  &quot;card=X;device=Y&quot;
     * - Other devices may use a number or any other string.
     */&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;open_output_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;audio_hw_device&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                              &lt;span class=&quot;n&quot;&gt;audio_io_handle_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                              &lt;span class=&quot;n&quot;&gt;audio_devices_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;devices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                              &lt;span class=&quot;n&quot;&gt;audio_output_flags_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                              &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;audio_config&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                              &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;audio_stream_out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stream_out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                              &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close_output_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;audio_hw_device&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;audio_stream_out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stream_out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/** This method creates and opens the audio hardware input stream */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;open_input_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;audio_hw_device&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                             &lt;span class=&quot;n&quot;&gt;audio_io_handle_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                             &lt;span class=&quot;n&quot;&gt;audio_devices_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;devices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                             &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;audio_config&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                             &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;audio_stream_in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stream_in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                             &lt;span class=&quot;n&quot;&gt;audio_input_flags_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                             &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                             &lt;span class=&quot;n&quot;&gt;audio_source_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close_input_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;audio_hw_device&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                               &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;audio_stream_in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stream_in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;......&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在上面音频硬件设备结构体 &lt;code class=&quot;highlighter-rouge&quot;&gt;audio_hw_device&lt;/code&gt; 的定义中，第一个结构体成员就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;struct hw_device_t&lt;/code&gt; 类型的，而其他的结构体成员都是函数指针，例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;open_output_stream&lt;/code&gt; 函数就是用来打开播放音频的扬声器设备，&lt;code class=&quot;highlighter-rouge&quot;&gt;open_input_stream&lt;/code&gt; 函数则是用来打开录音用的麦克风设备。&lt;/p&gt;

&lt;h3 id=&quot;step-4定义-struct-hw_module_methods_t-函数列表变量&quot;&gt;step 4：定义 struct hw_module_methods_t 函数列表变量&lt;/h3&gt;
&lt;p&gt;在前面介绍的结构体 hw_module_t 的定义中就有一个 hw_module_methods_t 函数指针类型的成员&lt;code class=&quot;highlighter-rouge&quot;&gt;open&lt;/code&gt;，该函数的作用就是让&lt;strong&gt;硬件模块&lt;/strong&gt;打开&lt;strong&gt;硬件设备&lt;/strong&gt;，然后对特定硬件设备（例如上面的 struct audio_device_t结构体）中定义函数指针变量进行赋值绑定，所以在每个&lt;strong&gt;硬件模块&lt;/strong&gt;都要实现这样一个变量。&lt;/p&gt;

&lt;p&gt;struct audio_module 结构体中 &lt;code class=&quot;highlighter-rouge&quot;&gt;struct hw_module_t 类型的成员 common &lt;/code&gt;中的 hw_module_methods_t 函数指针成员的实现绑定如下所示：
代码路径：&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;aosp&amp;gt;/generic/goldfish/audio/audio_hw.c&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hw_module_methods_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hal_module_methods&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adev_open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到，在 audio HAL 模块中使用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;adev_open&lt;/code&gt; 函数来初始化了 struct hw_module_methods_t 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;open&lt;/code&gt; 函数指针成员。我们现在回过头来看 &lt;strong&gt;step 2&lt;/strong&gt;中 &lt;strong&gt;struct audio_module HAL_MODULE_INFO_SYM&lt;/strong&gt; 变量的定义中，audio_module 中的第一个成员 common中的结构体变量 methods 的指针就是被初始化指向了现在这里定义的 &lt;code class=&quot;highlighter-rouge&quot;&gt;hal_module_methods&lt;/code&gt; 变量。&lt;/p&gt;

&lt;h3 id=&quot;step-5adev_open-函数的实现&quot;&gt;step 5：adev_open 函数的实现&lt;/h3&gt;
&lt;p&gt;最后，我们来看看 &lt;code class=&quot;highlighter-rouge&quot;&gt;adev_open&lt;/code&gt; 函数的实现，看看它是如何通过 audio_module 硬件模块对象来打开 audio_hw_device 硬件设备对象。
代码路径：&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;aosp&amp;gt;/generic/goldfish/audio/audio_hw.c&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;adev_open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hw_module_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                     &lt;span class=&quot;n&quot;&gt;hw_device_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;generic_audio_device&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;adev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strcmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AUDIO_HARDWARE_INTERFACE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EINVAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AUDIO_DEVICE_NAME&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;O_RDWR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ENOSYS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;adev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;generic_audio_device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;adev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;adev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HARDWARE_DEVICE_TAG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;adev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AUDIO_DEVICE_API_VERSION_2_0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;adev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hw_module_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;adev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adev_close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;adev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;init_check&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adev_init_check&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;adev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_voice_volume&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adev_set_voice_volume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;adev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_master_volume&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adev_set_master_volume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;adev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_master_volume&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adev_get_master_volume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;adev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_master_mute&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adev_set_master_mute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;adev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_master_mute&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adev_get_master_mute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;adev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_mode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adev_set_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;adev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_mic_mute&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adev_set_mic_mute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;adev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_mic_mute&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adev_get_mic_mute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;adev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_parameters&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adev_set_parameters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;adev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_parameters&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adev_get_parameters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;adev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_input_buffer_size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adev_get_input_buffer_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;adev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;open_output_stream&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adev_open_output_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;adev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close_output_stream&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adev_close_output_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;adev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;open_input_stream&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adev_open_input_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;adev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close_input_stream&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adev_close_input_stream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;adev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adev_dump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;adev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里再补充一个小的定义，&lt;code class=&quot;highlighter-rouge&quot;&gt;struct generic_audio_device&lt;/code&gt; 中的第一个成员 &lt;code class=&quot;highlighter-rouge&quot;&gt;device&lt;/code&gt; 就是我们前面提到的 &lt;code class=&quot;highlighter-rouge&quot;&gt;struct audio_hw_device&lt;/code&gt; 结构体，它的定义如下:
代码路径：&lt;code class=&quot;highlighter-rouge&quot;&gt;/hardware/libaudio/audio_hw.c&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;generic_audio_device&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;audio_hw_device&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pthread_mutex_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;audio_stream_out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;audio_stream_in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mic_mute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们可以从 &lt;code class=&quot;highlighter-rouge&quot;&gt;adev_open&lt;/code&gt; 函数中的实现中看到，它里面的主要工作就是做一些对 &lt;code class=&quot;highlighter-rouge&quot;&gt;struct audio_hw_device&lt;/code&gt; 对象的初始化，将其定义的函数指针指向对应的已经实现好的函数中。例如，这里将&lt;code class=&quot;highlighter-rouge&quot;&gt;struct audio_hw_device&lt;/code&gt;中定义的 &lt;code class=&quot;highlighter-rouge&quot;&gt;open_output_stream&lt;/code&gt; 函数指针成员指向了 &lt;code class=&quot;highlighter-rouge&quot;&gt;adev_open_output_stream&lt;/code&gt; 函数。这样在 Framework 层调用的 &lt;code class=&quot;highlighter-rouge&quot;&gt;struct audio_hw_device&lt;/code&gt; 对象的 &lt;code class=&quot;highlighter-rouge&quot;&gt;open_output_stream&lt;/code&gt; 函数，其实最终调用的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;adev_open_output_stream&lt;/code&gt;函数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这里，还有一点需要特别注意的就是我们所打开的硬件设备对象是怎么返回的？&lt;/strong&gt;
答案就是它是通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;open&lt;/code&gt; 函数中的第三个参数 &lt;code class=&quot;highlighter-rouge&quot;&gt;hw_device_t** device&lt;/code&gt;返回的。在 open 函数初始化并打开特定的硬件设备之后，它就将硬件设备结构体中的第一个成员 &lt;code class=&quot;highlighter-rouge&quot;&gt;struct audio_hw_device&lt;/code&gt; 类型的 common 对象返回。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;那么为什么这里返回的是 hw_device_t** 类型的硬件设备，而是不是audio_hw_device** 类型呢？&lt;/strong&gt;
其实这个问题在前面在介绍 &lt;code class=&quot;highlighter-rouge&quot;&gt;hw_module_methods_t&lt;/code&gt; 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;open&lt;/code&gt; 函数时已经提到过了。这里主要也蕴含着面向对象编程中的另外一种重要思想&lt;strong&gt;多态&lt;/strong&gt;，这使得使用的 hw_device_t 指针就可以访问到子类中继承了父类的属性和方法，如果要获得某个子类所特有的属性，那么只要将其进行类型的强制转换即可。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;理解 Android HAL 层最关键的还是要弄清楚 hw_module_t 、 hw_device_t、 hw_module_methods_t 这三个结构体的含义即关系，以及如何基于这三个结构体来实现特定硬件的&lt;strong&gt;硬件模块结构体&lt;/strong&gt;、&lt;strong&gt;硬件设备结构体&lt;/strong&gt;、&lt;strong&gt;硬件模块方法列表结构体&lt;/strong&gt;。其实从面向对象编程的角度来考虑，前面三者和后面三者之间的关系，就好比是父类和子类的关系，如下图所示：
&lt;img src=&quot;https://picturebed.obs.cn-east-2.myhuaweicloud.com/blogPictures/android_hal_architecture.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;后面，我可能会写一片关于 Android 系统加载 HAL 模块的文章。&lt;/p&gt;

&lt;h2 id=&quot;参考文章&quot;&gt;参考文章&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;罗升阳. Android 系统源代码情景分析作者. 电子工业出版社, 2012: 13-44&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Sun, 26 Mar 2017 03:56:24 +0800</pubDate>
        <link>http://localhost:4000/android/2017/03/26/Android-HAL%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html</link>
        <guid isPermaLink="true">http://localhost:4000/android/2017/03/26/Android-HAL%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html</guid>
        
        <category>HAL</category>
        
        <category>Android</category>
        
        
        <category>android</category>
        
      </item>
    
      <item>
        <title>Android NDK  vs AOSP Build System</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近自己一直在做有关 Android 系统源码底层的开发，就经常接触到 &lt;code class=&quot;highlighter-rouge&quot;&gt;Android NDK&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;AOSP(Android Open Source Project) Build System&lt;/code&gt; 这两个东西，但是由于他们两者都可以将 &lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt; 代码编译成可执行文件或者动态链接库，导致我经常将这两者弄混淆了。所以，痛定思痛，不想再被这种似四而非的感觉折磨了，今天就抽空写下这篇文章来捋清楚两者之间关系。&lt;/p&gt;

&lt;h1 id=&quot;android-ndk&quot;&gt;Android NDK&lt;/h1&gt;

&lt;h2 id=&quot;android-ndk-是什么&quot;&gt;Android NDK 是什么？&lt;/h2&gt;
&lt;p&gt;先引用一段来自 &lt;a href=&quot;https://developer.android.com/ndk/index.html&quot;&gt;Android NDK 官网&lt;/a&gt;上的非常简洁的介绍吧：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;The Android NDK is a toolset that lets you implement parts of your app using native-code languages such as C and C++. For certain types of apps, this can help you reuse code libraries written in those languages.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上面的介绍我觉得已经解释地非常清楚了，我再扩展地补充一下：Android NDK 本质上是一套&lt;code class=&quot;highlighter-rouge&quot;&gt;交叉编译工具集&lt;/code&gt;，它可以将 C/C++ 源码编译成适用于不同硬件平台的&lt;code class=&quot;highlighter-rouge&quot;&gt;库文件&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;可执行文件&lt;/code&gt;，而这些库文件和可执行文件可以被上层的基于 Java 语言编写的 APP 加载调用，从而实现了 C/C++ 源码在 APP 中的复用。&lt;/p&gt;

&lt;p&gt;下面这幅图就非常简洁地体现了 NDK 的用途：
&lt;img src=&quot;https://picturebed.obs.cn-east-2.myhuaweicloud.com/blogPictures/Screen%20Shot%202016-12-15%20at%209.02.21%20PM.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;android-ndk-应用实例&quot;&gt;Android NDK 应用实例&lt;/h2&gt;

&lt;p&gt;例如，在图像处理中我们常用的 &lt;code class=&quot;highlighter-rouge&quot;&gt;OpenCV&lt;/code&gt; 库就是使用 C++ 编写的，如果我们想在我们使用 Java 开发的 Android APP 中使用 OpenCV 库中的一些处理函数，那么该怎么办呢？
当然，你可以直接去找基于 Java 实现的 OpenCV 的 jar 包，然后去调用对应的函数，但是这种Java 实现版本的 OpenCV 在处理的效率上肯定不及 C++ 实现版本的 OpenCV（尤其是在做图形处理方面）。
所以，另外一种方法就是通过 Android NDK 工具将 OpenCV 的代码编译成指定硬件平台的库文件，然后在 Android APP 进程中通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;JNI&lt;/code&gt; 的方式来使用 OpenCV 中提供的处理函数，实现自己想要的某种功能。&lt;/p&gt;

&lt;h2 id=&quot;android-ndk-编译系统&quot;&gt;Android NDK 编译系统&lt;/h2&gt;
&lt;p&gt;Android NDK 编译系统其实本质上就是一系列的&lt;code class=&quot;highlighter-rouge&quot;&gt;交叉编译工具链&lt;/code&gt;，而 NDK 中所使用的编译脚本 &lt;code class=&quot;highlighter-rouge&quot;&gt;ndk-build&lt;/code&gt; 就是根据编译配置文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;Android.mk&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;Application.mk&lt;/code&gt; 来调用这些交叉编译工具链中的工具编译生成指定 ABI 平台下目标链接库文件或者可执行文件。&lt;/p&gt;

&lt;p&gt;这里我觉得还是有必要多费点文字对 Android NDK 包中的文件及目录的内容进行一个说明，以便大家对 NDK 有更加深一步的理解。NDK 包中的文件及目录结构如下所示：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;woshijpf@woshijpf-OptiPlex-9020:~/Android/NDK/android-ndk-r12b&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;tree &lt;span class=&quot;nt&quot;&gt;-L&lt;/span&gt; 1
&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
|-- build
|-- CHANGELOG.md
|-- ndk-build
|-- ndk-depends
|-- ndk-gdb
|-- ndk-stack
|-- ndk-which
|-- platforms
|-- prebuilt
|-- python-packages
|-- shader-tools
|-- source.properties
|-- sources
&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; toolchains

7 directories, 7 files
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;build：该目录下包含了 ndk-build 编译脚本中所使用到的各种小的脚本文件，例如我们在 Android.mk 中常见的将源码编译成共享链接库文件的语句： &lt;code class=&quot;highlighter-rouge&quot;&gt;include $(BUILD_SHARED_LIBRARY)&lt;/code&gt;中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;BUILD_SHARED_LIBRARY&lt;/code&gt; 对应的就是一个编译脚本文件： &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;ndk-home&amp;gt;/build/core/build-shared-library.mk&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;ndk-build：NDK 的核心，NDK 编译所使用的最主要的编译脚本。&lt;/li&gt;
  &lt;li&gt;ndk-gdb：调试 NDK 编译出来的库的工具。&lt;/li&gt;
  &lt;li&gt;ndk-stack：对 Android 系统运行时共享链接库崩溃时产生的 &lt;code class=&quot;highlighter-rouge&quot;&gt;tombstone&lt;/code&gt; 文件进行解析的工具。它在调试异常崩溃 Bug 时定为到具体出错的源码位置非常有帮助，具体使用方法详见我的这篇博客：&lt;a href=&quot;http://woshijpf.github.io/2016/06/14/Android-NDK-Tombstone-Crash-%E5%88%86%E6%9E%90/&quot;&gt;Android NDK Tombstone/Crash 分析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;platforms：这个文件夹里保存的是各个 Android 系统版本下不同硬件平台对应的 NDK 提供的系统共享链接库文件，例如：&lt;code class=&quot;highlighter-rouge&quot;&gt;liblog.so, libdl.so, libc.so等等&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;source：这个目录下主要包含的就是 NDK 所中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;C++ STL&lt;/code&gt; 库的源码，有 &lt;code class=&quot;highlighter-rouge&quot;&gt;gnu_stl&lt;/code&gt; 的实现，也有 &lt;code class=&quot;highlighter-rouge&quot;&gt;llvm-stl&lt;/code&gt;的实现。&lt;/li&gt;
  &lt;li&gt;toolchains：这个目录也是非常关键的一个目录，它里面包含了不同目标硬件平台下面的交叉编译工具，可以将 C/C++ 库编译成可运行在 &lt;code class=&quot;highlighter-rouge&quot;&gt;arm,x86,x86-64,mips&lt;/code&gt;等不同硬件平台上面。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里就不对 &lt;code class=&quot;highlighter-rouge&quot;&gt;Android.mk&lt;/code&gt; 编译配置文件的编写方法展开说明了，有关内容可以参见下面这篇文章：&lt;a href=&quot;http://web.guohuiwang.com/technical-notes/androidndk1&quot;&gt;Mastering Android NDK Build System - Part 1: Techniques with ndk-build&lt;/a&gt;和&lt;a href=&quot;https://developer.android.com/ndk/guides/android_mk.html&quot;&gt;Android.mk&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;android-ndk-中系统提供的共享链接库&quot;&gt;Android NDK 中系统提供的共享链接库&lt;/h2&gt;
&lt;p&gt;有时我们的自己编写的源码中除了实现某种特定的功能之外，可能还会在C/C++代码中使用到日志打印输出函数，而这个日志打印函数就位于 Android NDK 中 Android 系统提供的 &lt;code class=&quot;highlighter-rouge&quot;&gt;liblog.so&lt;/code&gt; 库中。除了 liblog.so 库之外，NDK 还提供了下面这些系统共享链接库供我们自己的源码进行加载调用：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;woshijpf@woshijpf-OptiPlex-9020:~/Android/NDK/android-ndk-r12b/platforms/android-22/arch-x86/usr/lib&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-al&lt;/span&gt;
total 10996
drwxr-xr-x 2 woshijpf woshijpf    4096 Jun 15  2016 &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
drwxr-xr-x 4 woshijpf woshijpf    4096 Jun 15  2016 ..
&lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt; 1 woshijpf woshijpf    2204 Jun 15  2016 crtbegin_dynamic.o
&lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt; 1 woshijpf woshijpf    1992 Jun 15  2016 crtbegin_so.o
&lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt; 1 woshijpf woshijpf    2204 Jun 15  2016 crtbegin_static.o
&lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt; 1 woshijpf woshijpf     704 Jun 15  2016 crtend_android.o
&lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt; 1 woshijpf woshijpf     648 Jun 15  2016 crtend_so.o
&lt;span class=&quot;nt&quot;&gt;-rwxr-xr-x&lt;/span&gt; 1 woshijpf woshijpf   10772 Jun 15  2016 libEGL.so
&lt;span class=&quot;nt&quot;&gt;-rwxr-xr-x&lt;/span&gt; 1 woshijpf woshijpf   34640 Jun 15  2016 libGLESv1_CM.so
&lt;span class=&quot;nt&quot;&gt;-rwxr-xr-x&lt;/span&gt; 1 woshijpf woshijpf   28428 Jun 15  2016 libGLESv2.so
&lt;span class=&quot;nt&quot;&gt;-rwxr-xr-x&lt;/span&gt; 1 woshijpf woshijpf   46592 Jun 15  2016 libGLESv3.so
&lt;span class=&quot;nt&quot;&gt;-rwxr-xr-x&lt;/span&gt; 1 woshijpf woshijpf    6752 Jun 15  2016 libOpenMAXAL.so
&lt;span class=&quot;nt&quot;&gt;-rwxr-xr-x&lt;/span&gt; 1 woshijpf woshijpf    7036 Jun 15  2016 libOpenSLES.so
&lt;span class=&quot;nt&quot;&gt;-rwxr-xr-x&lt;/span&gt; 1 woshijpf woshijpf   28876 Jun 15  2016 libandroid.so
&lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt; 1 woshijpf woshijpf 8814206 Jun 15  2016 libc.a
&lt;span class=&quot;nt&quot;&gt;-rwxr-xr-x&lt;/span&gt; 1 woshijpf woshijpf  125464 Jun 15  2016 libc.so
&lt;span class=&quot;nt&quot;&gt;-rwxr-xr-x&lt;/span&gt; 1 woshijpf woshijpf    5400 Jun 15  2016 libdl.so
&lt;span class=&quot;nt&quot;&gt;-rwxr-xr-x&lt;/span&gt; 1 woshijpf woshijpf    5212 Jun 15  2016 libjnigraphics.so
&lt;span class=&quot;nt&quot;&gt;-rwxr-xr-x&lt;/span&gt; 1 woshijpf woshijpf    5436 Jun 15  2016 liblog.so
&lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt; 1 woshijpf woshijpf 1333352 Jun 15  2016 libm.a
&lt;span class=&quot;nt&quot;&gt;-rwxr-xr-x&lt;/span&gt; 1 woshijpf woshijpf   26708 Jun 15  2016 libm.so
&lt;span class=&quot;nt&quot;&gt;-rwxr-xr-x&lt;/span&gt; 1 woshijpf woshijpf   18184 Jun 15  2016 libmediandk.so
&lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt; 1 woshijpf woshijpf  105024 Jun 15  2016 libstdc++.a
&lt;span class=&quot;nt&quot;&gt;-rwxr-xr-x&lt;/span&gt; 1 woshijpf woshijpf    5536 Jun 15  2016 libstdc++.so
&lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt; 1 woshijpf woshijpf  575800 Jun 15  2016 libz.a
&lt;span class=&quot;nt&quot;&gt;-rwxr-xr-x&lt;/span&gt; 1 woshijpf woshijpf   11768 Jun 15  2016 libz.so
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;那么这些系统提供的共享链接库是怎么被加载使用的呢？&lt;/strong&gt;
例如，我现在写了一个 C++ 源文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;hello.cpp&lt;/code&gt;，并且在这个源文件中调用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;__android_log_print()&lt;/code&gt; 函数打印日志，那么我就需要在对应的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Android.mk&lt;/code&gt; 文件中加入下面这条语句来显示地链接 &lt;code class=&quot;highlighter-rouge&quot;&gt;/system/lib/liblog.so&lt;/code&gt; 库：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;LOCAL_LDLIBS :&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-llog&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;那么这些系统共享链接库是如何编译出来的呢？&lt;/strong&gt;
因为安全性和兼容性问题以及上层应用程序的需求，NDK 提供的只是 Android 系统中一小部分系统共享链接库，并且这些系统共享链接库都是在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Android 源码&lt;/code&gt; 编译时生成的，例如，&lt;code class=&quot;highlighter-rouge&quot;&gt;liblog.so&lt;/code&gt; 库就是由 Android 源码中 &lt;em&gt;/system/core/liblog/&lt;/em&gt; 目录下的源码编译而来的。而在 &lt;em&gt;$NDK/platforms/android-22/arch-arm/usr/include/android/log.h&lt;/em&gt; 头文件中声明的日志打印函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;__android_log_write()&lt;/code&gt; 的实际代码实现就在 Android 源码的 &lt;code class=&quot;highlighter-rouge&quot;&gt;/system/core/liblog/logd_write.c&lt;/code&gt; 文件中。&lt;/p&gt;

&lt;h2 id=&quot;相关参考文章&quot;&gt;相关参考文章&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.android.com/ndk/guides/stable_apis.html&quot;&gt;Android NDK Native APIs&lt;/a&gt;
&lt;a href=&quot;https://developer.android.com/ndk/guides/cpp-support.html&quot;&gt;C++ Library Support&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;aosp-build-system&quot;&gt;AOSP Build System&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AOSP&lt;/code&gt; 是 &lt;code class=&quot;highlighter-rouge&quot;&gt;Android Open Source Project&lt;/code&gt; 的简称，接下来用我就用它等价地表示 Android 系统源码。&lt;/p&gt;

&lt;h2 id=&quot;aosp-build-system-是什么&quot;&gt;AOSP Build System 是什么？&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AOSP Build System&lt;/code&gt; 是用来编译 Android 系统，Android SDK 以及相关文档的一套框架。该编译系统主要由 Make 文件（&lt;strong&gt;注意：这里的 Make 文件不是 Makefile 文件，而是 Android 编译系统自己构架的一套编译配置文件，通常以*.mk 为文件后缀&lt;/strong&gt;），Shell 脚本以及 Python 脚本组成，其中最主要的是 Make 文件。&lt;/p&gt;

&lt;p&gt;在 Android Build System 中编译所使用到的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Make&lt;/code&gt; 文件主要分为三类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第一类是 Build 系统核心文件，此类文件定义了整个 Build 系统的框架，而其他所有 Make 文件都是在这个框架的基础上编写出来的。&lt;/li&gt;
  &lt;li&gt;第二类是针对某个产品（一个产品可能是某个型号的手机或者平板电脑）的 Make 文件，这些文件通常位于 device 目录下，该目录下又以公司名以及产品名分为两级目录。&lt;/li&gt;
  &lt;li&gt;第三类是针对某个模块的 Make 文件。整个 Android 系统中，包含了大量的模块，每个模块都有一个专门的 Make 文件，这类文件的名称统一为 &lt;code class=&quot;highlighter-rouge&quot;&gt;Android.mk&lt;/code&gt;，该文件中定义了如何编译当前模块。Build 系统会在整个源码树中扫描名称为“Android.mk”的文件并根据其中的内容执行模块的编译。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;aosp-build-system-所依赖的编译工具&quot;&gt;AOSP Build System 所依赖的编译工具&lt;/h2&gt;
&lt;p&gt;Android 系统从下到上主要分为下面5层，而每一层所使用的编程语言如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Kernel：Android 定制化过的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Linux Kernel&lt;/code&gt;，使用的当然是 &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; 语言了。&lt;/li&gt;
  &lt;li&gt;HAL：这一层是用户态驱动层，它主要功能是和下层 Kernel 中的硬件驱动程序进行交互，这一层主要使用的语言是 &lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;Frameworks native：这一层是 Android 系统核心组件的实现位置，在这一层中主要通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;C++&lt;/code&gt; 语言来实现。&lt;/li&gt;
  &lt;li&gt;Frameworks java：这一层其实是对 Frameworks native 层套上一层 Java 的外壳，封装成 Android SDK 提供给上层的 APP 开发者进行调用，这一层主要使用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt; 语言进行实现。&lt;/li&gt;
  &lt;li&gt;APP：这一层主要面向的是 Android APP 开发人员，并且 Android 提供的 SDK 是基于 Java 语言的，所以 APP 的代码实现也是 &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt; 语言。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;既然 Android 系统源码中包含了 3 种编程语言，那么在 &lt;code class=&quot;highlighter-rouge&quot;&gt;AOSP Build System&lt;/code&gt; 中肯定也使用了许多编译工具来进行编译（&lt;strong&gt;Android 官方推荐使用 Ubuntu 14.04 来对 Android 源码进行编译，所以这里就以 Ubuntu 系统中所使用的编译工具为例&lt;/strong&gt;）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;编译 C/C++ 代码：使用 Ubuntu 14.04 中自带的 &lt;code class=&quot;highlighter-rouge&quot;&gt;gcc&lt;/code&gt; 编译器即可。&lt;/li&gt;
  &lt;li&gt;编译 Java 代码：在 Ubuntu 14.04 中推荐使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;OpenJDK-1.7&lt;/code&gt; 来进行编译。&lt;/li&gt;
  &lt;li&gt;make 工具：前面提到 AOSP Build System 是基于 make 工具，所以这里也使用 Ubuntu 14.04 中自带的 &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 工具即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;aosp-build-system-编译系统共享链接库的方法&quot;&gt;AOSP Build System 编译系统共享链接库的方法&lt;/h2&gt;
&lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;AOSP Build System 是什么？&lt;/code&gt; 小节中，我提到了 Android 系统源码中也使用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;Android.mk&lt;/code&gt; 文件来将某个模块编译成库文件或者可执行文件。&lt;/p&gt;

&lt;p&gt;例如，Android 系统源码中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;AudioFlinger&lt;/code&gt; 服务对应使用的是系统中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;libaudioflinge.so&lt;/code&gt;共享链接库文件 ，该共享链接库的源码实现位于 &lt;code class=&quot;highlighter-rouge&quot;&gt;frameworks/av/services/audioflinger&lt;/code&gt;，在同一目录下面的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Android.mk&lt;/code&gt; 编译配置文件如下所示：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;LOCAL_SRC_FILES:=               \ # 编译该模块所需要使用到的源文件
    AudioFlinger.cpp            \
    Threads.cpp                 \
    Tracks.cpp                  \
    Effects.cpp                 \
    AudioMixer.cpp.arm          \
    PatchPanel.cpp

LOCAL_SRC_FILES += StateQueue.cpp

LOCAL_C_INCLUDES := \
    $(TOPDIR)frameworks/av/services/audiopolicy \
    $(call include-path-for, audio-effects) \
    $(call include-path-for, audio-utils)

LOCAL_SHARED_LIBRARIES := \ # 链接该模块所依赖的共享链接库文件
    libaudioresampler \
    libaudioutils \
    libcommon_time_client \
    libcutils \
    libutils \
    liblog \
    libbinder \
    libmedia \
    libnbaio \
    libhardware \
    libhardware_legacy \
    libeffects \
    libpowermanager \
    libserviceutility

LOCAL_STATIC_LIBRARIES := \ # 链接该模块所依赖的静态链接库文件
    libscheduling_policy \
    libcpustats \
    libmedia_helper

LOCAL_MODULE:= libaudioflinger 

LOCAL_CFLAGS += -fvisibility=hidden #隐藏共享链接库中的符号，使之不被其他共享库所访问

include $(BUILD_SHARED_LIBRARY) # 编译成 libaudioflinger.so 库文件
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 Android 源码树的根目录下运行下面的命令来配置好 Android 源码编译的环境：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;source &lt;/span&gt;build/envsetup.sh
&lt;span class=&quot;nv&quot;&gt;$lunch&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 选择自己需要编译的 Android 系统版本&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;有了 Android 编译环境之后，只需要在将当前的工作目录切换到 &lt;em&gt;frameworks/av/services/audioflinger&lt;/em&gt; 目录下来编译 &lt;code class=&quot;highlighter-rouge&quot;&gt;AudioFlinger&lt;/code&gt; 模块&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 由于 libaudioflinger.so 所需依赖其他的系统共享链接库文件，所以需要先把整个 Android 源码生成这些共享链接库文件
$ mm # 读取当前工作目录下的 Android.mk 文件，编译 libaudioflinger.so 共享链接库文件
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;虽然咋一看上去 Android 源码中某个模块的编译配置文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;Android.mk&lt;/code&gt;和 NDK 中所用的编译配置文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;Android.mk&lt;/code&gt; 没有什么不同，但是其实还是有一些细微的区别的，尤其是在&lt;strong&gt;使用共享链接库&lt;/strong&gt;方面。&lt;/p&gt;

&lt;p&gt;例如，上面 Android 系统中源码编译出来的 &lt;code class=&quot;highlighter-rouge&quot;&gt;libaudioflinger.so&lt;/code&gt; 库文件中链接 &lt;code class=&quot;highlighter-rouge&quot;&gt;liblog.so&lt;/code&gt; 库文件使用的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;LOCAL_SHARED_LIBRARIES&lt;/code&gt; 编译变量：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;LOCAL_SHARED_LIBRARIES := \ # 链接该模块所依赖的共享链接库文件
    ...
    liblog \
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而在 NDK 编译自己使用 C/C++ 编写的模块时，如果要链接 &lt;code class=&quot;highlighter-rouge&quot;&gt;liblog.so&lt;/code&gt; 库文件，&lt;code class=&quot;highlighter-rouge&quot;&gt;Android.mk&lt;/code&gt; 文件中的写法则是：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;LOCAL_LDLIBS := -llog
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;所以，我们可以看出来在 &lt;code class=&quot;highlighter-rouge&quot;&gt;AOSP&lt;/code&gt; 中所有编译出来的系统链接库文件（不管是静态库文件还是共享链接库文件）对 &lt;code class=&quot;highlighter-rouge&quot;&gt;AOSP&lt;/code&gt; 中各个模块都是可见和可以被链接使用的，而对于 NDK 来说它只能通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;LOCAL_LDLIBS&lt;/code&gt; 的变量来链接使用 Android 系统中提供的一小部分系统链接库文件。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;相关参考文章-1&quot;&gt;相关参考文章&lt;/h2&gt;
&lt;p&gt;有关 AOSP Build System 更加详细的介绍，可以参考下面的的文章：
&lt;a href=&quot;https://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/&quot;&gt;理解 Android Build 系统&lt;/a&gt;
&lt;strong&gt;《Embedded Android》 Chapter 4 – The Build System&lt;/strong&gt;
&lt;a href=&quot;https://aabdelfattah.wordpress.com/2013/04/08/android-build-system-ultimate-guide/&quot;&gt;Android Build System Ultimate Guide&lt;/a&gt;
&lt;a href=&quot;http://source.android.com/source/initializing.html&quot;&gt;Establishing a Build Environment&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;android-ndk-和-aosp-build-system-的差异&quot;&gt;Android NDK 和 AOSP Build System 的差异&lt;/h1&gt;
&lt;p&gt;前面我们对 &lt;code class=&quot;highlighter-rouge&quot;&gt;Android NDK&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;AOSP Build System&lt;/code&gt; 做了比较详细的说明，所以在这一小节中就是对两者从下面几个方面进行一个差异对比：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;两种编译系统面向的开发人员群体&lt;/li&gt;
  &lt;li&gt;生成的链接库或可执行文件的目的&lt;/li&gt;
  &lt;li&gt;系统共享链接库的支持&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;两种编译系统面向的开发人员群体&quot;&gt;两种编译系统面向的开发人员群体&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Android NDK&lt;/code&gt; 它所面对的开发人员群体是&lt;code class=&quot;highlighter-rouge&quot;&gt;APP&lt;/code&gt; 开发人员，他们想使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt; 代码来实现某种功能，然后在上层 APP 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt; 代码中来通过 JNI 的方式来调用这些函数。例如，一些手机游戏 APP 的开发人员，为了使得游戏运行时画面更加流畅，他们就常常会把这些图像渲染这块耗时和性能要求较高的模块通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt; 代码调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;OpenGLES API&lt;/code&gt; 函数来实现，然后通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;ndk-build&lt;/code&gt; 编译成共享库文件，然后被上层的 APP 中的 Java 代码加载调用。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AOSP Build System&lt;/code&gt; 面向的开发人员群体则是一些底层操作系统的开发人员，他们需要根据自己的需求和硬件平台的特性对 &lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt; 源码进行一个定制修改，然后通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;AOSP Build System&lt;/code&gt; 重新编译得到自己想要的 Android 系统的镜像和库文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;生成的链接库或可执行文件的目的&quot;&gt;生成的链接库或可执行文件的目的&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Android NDK&lt;/code&gt; 生成链接库或可执行文件的目的是为了执行实现上层 APP 层中的需要通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt; 才能实现的某种功能，还是上面举过的例子，手机游戏 APP 开发人员需要通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt; 才能实现一些性能要求很高的图像渲染操作。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AOSP Build System&lt;/code&gt; 中生成的链接库文件或可执行文件都是 Android 系统运行起来&lt;code class=&quot;highlighter-rouge&quot;&gt;必须依赖&lt;/code&gt;的库文件，非常重要！！！例如，我们前面一直举的  &lt;code class=&quot;highlighter-rouge&quot;&gt;liblog.so&lt;/code&gt; 就是由 &lt;code class=&quot;highlighter-rouge&quot;&gt;AOSP Build System&lt;/code&gt; 编译出来的一个系统共享链接库文件，如果没有这个文件，那么 Android 系统的日志系统就挂了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;系统共享链接库的支持&quot;&gt;系统共享链接库的支持&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Android NDK&lt;/code&gt; 中支持用户自己编写的 C/C++ 代码链接调用一部分系统共享链接库文件，例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;liblog.so, libOpenSLES.so, libGLESv2.so&lt;/code&gt; 等库文件，有关 Andorid NDK 支持那些系统库文件，详见 NDK 的官方文档：&lt;a href=&quot;https://developer.android.com/ndk/guides/stable_apis.html&quot;&gt;Android NDK Native APIs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AOSP Build System&lt;/code&gt; 就好比是系统共享链接库的“妈”，既然这些库文件都由它编译出来的，那么 &lt;code class=&quot;highlighter-rouge&quot;&gt;AOSP&lt;/code&gt; 中任意一个模块肯定都可以使用全部的系统共享链接库文件。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 17 Dec 2016 18:39:07 +0800</pubDate>
        <link>http://localhost:4000/android/2016/12/17/Android-NDK-vs-AOSP-Build-System.html</link>
        <guid isPermaLink="true">http://localhost:4000/android/2016/12/17/Android-NDK-vs-AOSP-Build-System.html</guid>
        
        <category>NDK</category>
        
        <category>AOSP</category>
        
        <category>Android</category>
        
        
        <category>android</category>
        
      </item>
    
      <item>
        <title>单生产者和单消费者共同操作同一个环形缓冲区的问题</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://picturebed.obs.cn-east-2.myhuaweicloud.com/blogPictures/circular_buffer.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;问题描述&quot;&gt;问题描述&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;本问题只针对单个生产者进程和单个消费者进程的问题进行讨论。&lt;/li&gt;
  &lt;li&gt;生产者进程和消费者进程之间通过共享内存的方式进行IPC通信。&lt;/li&gt;
  &lt;li&gt;环形缓冲区存放在共享内存中，并且环形缓冲区中环形缓冲单元的个数为 &lt;code class=&quot;highlighter-rouge&quot;&gt;2^N&lt;/code&gt; 个（N为大于1的正整数），环形缓冲区的数据结构定义为：
    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;cp&quot;&gt;#define RING_BUFFER_SIZE N
&lt;/span&gt;    
 &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RingBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w_pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//环形缓冲区写入位置值&lt;/span&gt;
     &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r_pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//环形缓冲区读取位置值&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;data_block&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//data_block 是环形缓冲区中所存放的数据单元的类型&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;在创建环形缓冲区之后，RingBuffer 结构体中的成员&lt;code class=&quot;highlighter-rouge&quot;&gt;w_pos&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;r_pos&lt;/code&gt;都被初始化为 0。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;判断环形缓冲区是否为空的伪代码：
    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w_pos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r_pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
     &lt;span class=&quot;c1&quot;&gt;//判断语句为真，RingBuffer 为空&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;判断环形缓冲区是否为满的伪代码：
    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w_pos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r_pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
     &lt;span class=&quot;c1&quot;&gt;//判断语句为真，RingBuffer 为满&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;生产者进程中的处理逻辑伪代码：
    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w_pos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r_pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//缓冲区满了&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
     &lt;span class=&quot;c1&quot;&gt;//否则，则将数据填入到环形缓冲区中空闲的单元中&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w_pos&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;some_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//将需要写入的数据写入到指定的环形缓冲区单元中&lt;/span&gt;
        
     &lt;span class=&quot;n&quot;&gt;w_pos&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//将写入位置向前移动&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;消费者进程中的处理逻辑伪代码：
    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w_pos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r_pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//缓冲区为空&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
     &lt;span class=&quot;c1&quot;&gt;//否则，从环形缓冲区中读取数据出来进行处理&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r_pos&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//process() 函数只是对读取到的数据进行一个处理&lt;/span&gt;
        
     &lt;span class=&quot;n&quot;&gt;r_pos&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//将读取位置向前移动&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h1 id=&quot;疑惑&quot;&gt;疑惑？&lt;/h1&gt;
    &lt;p&gt;如果按照上面提出的条件和处理逻辑，当生产者进程和消费者进程同时运行时，如果不加&lt;code class=&quot;highlighter-rouge&quot;&gt;互斥锁&lt;/code&gt;，上面代码是否会出现&lt;code class=&quot;highlighter-rouge&quot;&gt;Bug&lt;/code&gt;，或者不确定的状态？&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而且我想了很多遍生产者和消费者的处理逻辑，他们只会在最后执行语句 &lt;code class=&quot;highlighter-rouge&quot;&gt;w_pos++&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;r_pos++&lt;/code&gt; 时改变两个进程都共享的值，虽然 &lt;code class=&quot;highlighter-rouge&quot;&gt;w_pos++&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;r_pos++&lt;/code&gt; 的操作不是原子操作的，但是好像是不是原子操作都不会对结果产生影响，我就是在这里思考不清楚！不知道大家对此有什么看法呢？能否举出特殊的栗子来描述一下。&lt;/p&gt;

</description>
        <pubDate>Wed, 14 Dec 2016 08:58:26 +0800</pubDate>
        <link>http://localhost:4000/linux/2016/12/14/%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E5%8D%95%E6%B6%88%E8%B4%B9%E8%80%85%E5%85%B1%E5%90%8C%E6%93%8D%E4%BD%9C%E5%90%8C%E4%B8%80%E4%B8%AA%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E9%97%AE%E9%A2%98.html</link>
        <guid isPermaLink="true">http://localhost:4000/linux/2016/12/14/%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E5%8D%95%E6%B6%88%E8%B4%B9%E8%80%85%E5%85%B1%E5%90%8C%E6%93%8D%E4%BD%9C%E5%90%8C%E4%B8%80%E4%B8%AA%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E9%97%AE%E9%A2%98.html</guid>
        
        <category>同步</category>
        
        <category>生产者消费者</category>
        
        <category>环形缓冲区</category>
        
        <category>RingBuffer</category>
        
        
        <category>Linux</category>
        
      </item>
    
  </channel>
</rss>
